#                            JavaScript学习笔记

## 一：入门

### 1：编写位置

- js可以编写到网页内部的script标签
- js可以编写到外部js文件中然后通过script标签链接
- js可以编写到指定属性中去

### 2：编写位置

- 注释
- js严格区分大小写
- 在js中多个空格和换行会被忽略
- js每句话以分号结尾，会自动添加分号，但可能会出错

### 3：字面量和变量

- 字面量

  ​	字面量其实就是一个值，它的含义就是他的字面意思，在js中所有的字面量都可以直接使用，但并不方便

- 变量

  - ​	变量可以用来存储“字面量”，并且存储的字面量可以随意修改，通过变量可以对字面量尽享描述

  - 变量的使用

    ​	声明变量-->	let	变量名 / var	变量名

    ​	变量赋值 -->	变量名 = xxx

    ​	声明并赋值	——>let	变量	=	值	

### 4：变量的内存

变量中并不存储任何值，而是存储值的内存地址

![image-20230111151802216](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20230111151802216.png)

### 5：常量

在js中，使用const声明常量，常量只能赋值一次，重复赋值会报错

在js中除了常规的常量外，有一些对象类型的数据也会声明为常量

### 6：表示符

在js中，所有可以有我们自主命名的内容，都可以认为是一个标识符，像 变量名	函数名	类名……

命名规范：

1.标识符只能含有字母，数字，下划线，￥，且不能以数字开头

2.标识符不能是js中的关键字和保留字，也不建议用内置的函数或类名作为变量名

3.通常会用驼峰命名法——首字母小写，单个单词开头大写：maxlength——》maxLength

4.类名使用大驼峰命名法——首字母大写，单个单词开头大写：maxlength——》MaxLength

5.常量的字母会全部大写——》MAX_LENGTH

## 二：数据类型

### 1：类型检查

typeof运算符

1.typeof用来检查不同的值的类型

2.他会根据不同的值返回不同的结果

### 2：数值（Number）

1.在js中所有的整数和浮点数都是Number类型

2.js中的数值不能无限大，当数值超过一定范围后会显示近似值

3.Infinity是一个特殊的数值表示无穷

4.在js中进行一些精度比较高的运算要小心

5.NaN也是与一个特殊的值，表示非法的数值

### 3：大整数（BigInt）

1.大整数是用来表示一些比较的整数

2.大整数使用n结尾，它可以表示的数字范围是无限大



### 4：字符串（String）

1.在js中使用单引号或双引号表示字符串

2.转义字符

​	\  " ---->''

​	\  ‘ ---->'

​	\  \ ---->\ \

​	\  t ---->制表符

​	\  n ---->换行

3.模板字符串

​	使用反单引号来表示模板字符串

​	模板字符串中可以嵌入变量

4.使用typeof 检查一个字符串时会返回一个string

### 5：布尔值（Boolean）

1.布尔值只有两个true和false

2.布尔值主要用来进行逻辑判断

3.使用typeof 检查一个布尔值时会返回一个“boolean”

### 6：空值（Null）

1.空值只有一个null

2.空值用来表示空对象

3.使用typeof 检查一个空值时会返回一个“object”

4.使用typeof无法检查空值

### 7：未定义（Undefined）

1.Undefined类型的值只有一个就是Undefined

2.当声明一个变量没有赋值时，它的值就是Undefined

3.使用typeof 检查一个Undefined时会返回一个“Undefined”

### 8：符号（Symbol）

1.用来创建一个唯一的标识

2.使用typeof 检查一个符号时会返回一个“symbol”

### 9：概括

js中的原始值一共有七种

1.Number

2.BigInt

3.String

4.Boolean

5.Null

6.Undefined

7.Symbol

原始值在js中是不可变类型，一旦创建不能修改

### 10：类型转换——转换为字符串

类型转换是指将一种数据类型转换为其他类型，将其他类型转换为（字符串，数值和布尔值）

转换为字符串

​		1.调用toString（）方法进行转换

​				调用xxx的yyy方法：

​								xxx.yyy（）

​				null和undefined中没有toString（）函数

​		2.调用String（）函数进行转换

​				调用xxx函数：

​								xxx（）

​				原理：对于拥有toString方法的值调用String就是在调用toString方法，对于null直接转化为null，对于undefined直接转换为undefined

### 11：类型转换——转换为数值

1.使用Number（）函数进行转换

​		转换的情况：

​				1.字符串，如果字符串是一个合法的数字，则会直接转化为数字；如果字符串不是一个合法的数字，则转换为NaN；如果字符串是空串或纯空格，则准换为0.

​				2.布尔值，true转换为1，false转换为0。

​				3.null转换为0

​				4.undefined转换为 NaN

2.专门用来将字符串转换为数值的方法

​		1.parseInt（）——将一个字符串转换为整数，解析时会自左向右读取一个字符串，直到读取到字符串中的所有的有效的整数，也可以用这个方法对一个数字进行取整

​		2.parseFloathe（）——将一个字符串转换为浮点数，解析时，会自左向右读取一个字符串，直到读取到字符串中的所有的有效的小数

### 12：类型转换——转换为布尔值

使用Boolean（）函数进行转换

​	1.转换的情况

​		数字：0和NaN转换为false

​					其余是true

​		字符串：空串转换为false

​						其余是true

​		null和undefined都会转换为false

​		对象：都会转换为true

## 三：运算符

### 1：数字运算

```
var x = 7;		
var y = 8;		
var z = x + y;	
```

```
var x = 7;
var y = 8;
var z = x * y; 
```

| 运算符 | 描述         |
| :----- | :----------- |
| +      | 加法         |
| -      | 减法         |
| *      | 乘法         |
| /      | 除法         |
| %      | 取模（余数） |
| ++     | 递加         |
| --     | 递减         |

### 2：赋值运算符

| 运算符 | 例子   | 等同于    |
| :----- | :----- | :-------- |
| =      | x = y  | x = y     |
| +=     | x += y | x = x + y |
| -=     | x -= y | x = x - y |
| *=     | x *= y | x = x * y |
| /=     | x /= y | x = x / y |
| %=     | x %= y | x = x % y |

### 3：字符串运算符

```
txt1 = "Bill";
txt2 = "Gates";
txt3 = txt1 + " " + txt2; 
```

txt3 的结果将是：

```
Bill Gates
```

```
txt1 = "Hello ";
txt1 += "Kitty!"; 
```

txt1 的结果将是：

```
Hello Kitty!
```

### 4：字符串和数字的相加

```
x = 7 + 8;
y = "7" + 8;
z = "Hello" + 7;
```

x、y 和 z 的结果将是：

```
15
78
Hello7
```

### 5：比较运算符

| 运算符 | 描述           |
| :----- | :------------- |
| ==     | 等于           |
| ===    | 等值等型       |
| !=     | 不相等         |
| !==    | 不等值或不等型 |
| >      | 大于           |
| <      | 小于           |
| >=     | 大于或等于     |
| <=     | 小于或等于     |
| ?      | 三元运算符     |

### 6：逻辑运算符

| 运算符 | 描述   |
| :----- | :----- |
| &&     | 逻辑与 |
| \|\|   | 逻辑或 |
| !      | 逻辑非 |

### 7：关系运算符

1.关系运算符小于、大于、小于等于和大于等于执行的是两个数的比较运算，比较方式与算术比较运算相同。

每个关系运算符都返回一个布尔值：

```
var bResult1 = 2 > 1	//true
var bResult2 = 2 < 1	//false
```

2.对于字符串，第一个字符串中每个字符的代码都与会第二个字符串中对应位置的字符的代码进行数值比较。完成这种比较操作后，返回一个 Boolean 值。两个运算数都是字符串，所以比较的是它们的字符代码

3.比较数字和字符串

无论何时比较一个数字和一个字符串， 都会把字符串转换成数字，然后按照数字顺序比较它们。

### 8：相等运算符

1.相等 （==）

​		用来比较两个值是否相等，使用==比较两个不同类型的值时，他会将其转换为相同的值（通常是数值）然后再比较，null和undefined比较时会返回true；NaN不和任何值相等，包括他本身。

2.全等（===）

​		用来比较两个值是否全等；不会进行类型转换，类型不同直接返回false；null和undefined比较时会返回false

3不等（！=）

​		用来比较两个值是否不相等；会自动进行类型转换

4不全等（！==）

​		用来比较两个值是否不全等；不会自动进行类型转换

### 9：条件运算符

格式：条件表达式 ？ 表达式1 ：表达式2

执行顺序：执行时，会先对条件表达式进行求值判断，如果结果为true，则执行表达式1；如果结果为false，则执行表达式2

### 10：运算符的优先级

下表按从最高到最低的优先级列出JavaScript运算符。具有相同优先级的运算符按从左至右的顺序求值。

| 运算符                             | 描述                                         |
| ---------------------------------- | -------------------------------------------- |
| . [] ()                            | 字段访问、数组下标、函数调用以及表达式分组   |
| ++ -- - ~ ! delete new typeof void | 一元运算符、返回数据类型、对象创建、未定义值 |
| * / %                              | 乘法、除法、取模                             |
| + - +                              | 加法、减法、字符串连接                       |
| << >> >>>                          | 移位                                         |
| < <= > >= instanceof               | 小于、小于等于、大于、大于等于、instanceof   |
| == != === !==                      | 等于、不等于、严格相等、非严格相等           |
| &                                  | 按位与                                       |
| ^                                  | 按位异或                                     |
| \|                                 | 按位或                                       |
| &&                                 | 逻辑与                                       |
| \|\|                               | 逻辑或                                       |
| ?:                                 | 条件                                         |
| = oP=                              | 赋值、运算赋值                               |
| ,                                  | 多重求值                                     |

## 四：流程控制

### 1：代码块

1.使用{}来创建代码块，代码块可以用来对代码进行分组，在代码块中声明的变量无法在代码块的外部访问

2.let：在js中声明的变量具有块作用域

3.var:  在js中声明的变量不具有块作用域

### 2：if语句

1.语法：

​				if（条件表达式）{

​						语句

}

2.执行流程：

​		if语句在执行时会对条件表达式进行求值判断，如果结果为true则执行if后的语句，如果为false则不执行。如果if后的表达式不是布尔值则会转换为布尔值在运算

### 3：if-else语句

1.语法：

​		if（条件表达式）{

​						语句

​	}else{

​						语句

​	}

或者

​		if（条件表达式）{

​						语句1

​	}else	if（条件表达式）{

​						语句2

​	}else	if（条件表达式）{

​						语句3

​	}else	if（条件表达式）{

​						语句4

​	}else{

​						语句5

}

2.执行流程：

​	if-else语句在执行时会对条件表达式进行求值判断，如果结果为true则执行if后的语句，如果为false则执行else后的语句。

if-else if-else语句在执行时会自上向下依次对条件表达式进行求值判断，如果结果为true则执行当前if后的语句，执行完毕语句结束；如果为false则继续向下判断直到找到true。如果全部都为false则执行else后的语句；注意：一旦有执行的代码块，则下面的条件都不会在进行判断，所以要注意编写的逻辑顺序。

### 4：switch语句

1.语法：

​	switch（表达式）{

​		case	表达式：

​					代码

​					break

​	switch（表达式）{

​		case	表达式：

​					代码

​					break

​	default{

​		case	表达式：

​					代码

​					break

}

2：执行流程：

在执行时，回一次将switch后的表达式和case后的表达式进行全等比较，如果结果为true，则自当前case开始执行代码；如果为false则继续比较知道找到true；如果都为false，则执行default后的语句

3：注意：

当结果为true后当前case后的代码均会执行，可以用break来阻止其他代码块运行

### 5：循环语句

三要素：

1.初始化表达式（初始化变量）

2.条件表达式（设置循环运行的条件）

3.更新表单式

### 6：while循环

语法：

​	while（条件表达式）{

​					语句

}

执行流程：
				while语句在执行时会先对表达式进行判断，如果为true，则执行循环体，执行完毕，继续判断，如此重复。直到表达式结果为false，循环结束

### 7：do--while循环

语法：

​	do{

​		语句

}while（条件表达式）

执行流程：

​		在执行时，会先执行do后的循环体，执行完毕后，在对条件表达式进行判断，如果为true则继续执行，继续判断，如此重复，直到为false，循环结束

与while的区别：do-while可以确保循环至少执行一次

### 8：for循环

语法：

for（1初始化表达式；2条件表达式；3更新表达式）{

语句

}

执行流程：

​		1执行初始化表达式，初始化变量；2执行条件表达式，判断循环是否执行（true执行，false不执行）；3执行更新表达式，对初始化变量进行修改。

注意：

​		初始化表达式，在整个循环中只会执行一次

​		for循环中三个表达式都可以省略

​		使用let声明的变量是局部变量，只能在for循环内部访问；使用var声明的变量可以在for循环外部访问

​		创建死循环的方法：while（1）{}		for（；；）{}

### 9：循环嵌套

循环中可以嵌套一个循环

### 10：break和continue

break：

​	用来终止switch和循环语句；break执行后，当前的switch和循环语句会立即停止；break会终止离他最近的循环

continue：

​	用来跳过当次循环

## 五：对象

### 1:对象

​	对象中可以存储很多多个各个类型的数据，这些存储的数据称为属性。

​	向对象中添加属性：对象.属性名 = 属性值

​	读取对象中的属性：对象.属性

​	如果一个对象中没有属性会返回undefined

### 2：对象的属性名

属性名：

属性名通常是一个字符串，属性名可以是任何值。但如果太特殊需要使用【】来设置。建议属性名的设置按照表示符的规范命名。

也可以使用符号（symbol）作为属性名。当获取这个属性是必须使用symbol。使用这种方法添加的属性名通常是不希望外界访问的属性。方法对象【symbol】 = 属性值

in运算符

用来检查对象中是否含有某个属性。语法：属性名	in	对象	如果有返回true没有返回false

### 3：对象字面量

可以直接使用{}来创建对象。

使用{}创建的对象，可以直接向对象中添加属性。

语法：{	属性名：属性值，【属性名】：属性值，}

### 4：枚举属性

枚举属性只将对象中的所有属性全部获取。

for-in语句：

语法：for（let	propName	in	对象）{	语句	}

for-in循环会执行多次，有几个属性执行几次。每次执行时，都会将一个属性名赋值给我们定义的变量。

注意：使用符号添加的属性不可以被枚举。

### 5：可变类型

对象属于可变类型

对象创建完成后可以任意的添加删除修改对象中的属性 

注意：

当两个对象进行相等或全等比较时，比较的是对象的内存地址。如果有两个变量同时指向一个对象，通过一个变量改变对象时，另一个变量也会受到影响。

### 6：修改对象和变量

修改对象：

​		当修改一个对象时，所有指向该对象的变量都会收到影响。

修改变量：

​		修改变量只会影响当前变量。

在使用变量存储对象时，很容易该变变量指向的对象，所以通常情况下，声明存储对象的变量使用const。const只是进制变量被重新赋值。

### 7：方法

当一个对象的属性指向一个函数，那么称这个函数是这个对象的方法，调用函数被称为调用对象的方法

## 六：函数

### 1：简介

函数也是一个对象；它具有对象所有的功能；函数可以存储代码，并且可以调用代码

语法：function	函数名（）{	语句	}

调用函数就是执行函数中的代码

调用函数语法：函数对象（）

使用typeof检查函数会返回function

### 2：函数的定义方式

1.函数声明：function	函数名（）{语句}

2.函数表达式：const	变量 = function（）{语句}

3.箭头函数：（） =>{语句}

### 3：参数

在定义函数时，可以在函数中定义数量不等的参数（形参）。相当于在函数内部声明了对应的变量但是没有赋值。

实际参数（实参）：在定义函数时，可以在函数中定义数量不等的实参，实参会赋值给相应的形参

function	函数名（参数）{语句}

如果实参和形参数量相同，则一一对应；如果实参多于形参，则多余的实参不会使用；如果实参小于形参，则多余的形参为undefined

当箭头函数中只有一个参数时，可以省略（）

定义参数时，可以为参数设定默认值，默认值会在没有对应实参时生效

对象作为参数：

传递参数时，传递的不是变量本身，而是变量中存储的值。

修改对象时，如果有其它变量指向该对象，则这些变量都会收到影响。

### 4：函数的返回值

在函数中，可以通过return关键字来指定函数的返回值。

返回值就是函数的执行结果，函数调用完后会作为结果返回。

任何值都可以作为返回值，如果return后不跟任何值，则返回undefined，如果不写return，则依然返回undefined

箭头函数的返回值可以直接写在箭头的后面，如果设置对象字面量作为返回值需要使用（）括起来。

### 5：作用域

作用域指的是一个变量的可见区域。

作用域有两种

全局作用域：

​			全局作用域在网页运行时创建，在网页关闭后创建；所有直接编写到script标签内的代码都位于全局作用域中；可以在任意位置访问

局部作用域：

​			块作用域；再执行代码时创建，代码执行完毕后销毁；只能在内部访问，无法再外部访问。

​			函数作用域；在函数调用时产生，调用结束后销毁；函数每次调用都会产生一个全新的函数作用域；函数中定义的变量只能在内部访问。

作用域链：
				当我们使用一个变量时，js解释器会优先在当前作用域寻找变量，如果没有，则去向上一层寻找，以此类推。如果在全局作用域中也没找到，则报错

### 6：Window对象

在浏览器中，浏览器为我们提供了一个Window对象，可以直接访问

Window对象代表的是浏览器窗口，通过该对象对浏览器窗口进行操作，Window对象还负责存储js中的内置对象和浏览器的宿主对象。

Window对象的属性可以通过Window对象访问也可以直接访问。

函数可以认为是Window对象的方法

向Window对象中添加属性会自动成为全局变量。

在全局这中使用var声明的变量都会作为Window对象的属性保存。

使用function声明的函数都会作为Window对象的属性保存。

使用let声明的变量不会存储到Window对象中而存在到一个无法访问到的地方。

var没有块作用域但是有函数作用域。

### 7：提升

变量的提升：

​		使用var声明的变量，会在所有代码执行前被声明。

函数的提升：

​		使用函数声明创建的函数，会在所有代码执行前被创建。

### 8：debug

可以终止代码的执行

### 9：立即执行函数

立即执行函数（IIFE）

他是一个匿名的函数，并且只会调用一次。

可以用IIFE来创建一个一次性的函数作用域，避免变量冲突的问题。

### 10：this

在函数执行时，js解析器都会传递进一个隐含的参数，就是this。

this会指向一个对象，会根据函数调用方式的不同而不同。以函数形式调用时，指向window；以方法的形式调用时，指向调用方法的对象。

通过this可以在方法中引用调用方法的对象

箭头函数的this：

箭头函数：（【参数】） =>返回值

箭头函数没有自己的this，由外层作用域决定，箭头函数的this与他的调用方式无关。

### 11：严格模式

正常模式：

​		默认情况下均为正常模式，在正常模式下语法检查并不严格

严格模式	use strict：

​		语法检查更严格，提升性能，禁止一些语法

## 七：面向对象

### 1：简介

面向对象编程（OOP）

“面向对象编程”（Object Oriented Programming，缩写为OOP）是目前主流的编程范式。它的核心思想是将真实世界中各种复杂的关系，抽象为一个个对象，然后由对象之间的分工与合作，完成对真实世界的模拟。

### 2：类

在js中可以通过类（class）来区分不同的对象

类是对象模板，可以将对象中的属性和方法直接定义在类中，定义后就可以直接通过类来创建对象

通过同一个类创建的对象，我们成为同类对象。可以使用instanceof来检查一个对象有哪个类创建的。如果某个对象是由某个类创建的，我们称这个对象是这个类的实例。

语法：

class	类名（类名使用大驼峰命名法）	{}

const	类名 = class{}

通过类创建对象：new 类（）

类的代码块是用来设置对象属性的，不是什么代码就能写。实例属性只能通过实例访问静态属性只能通过类去访问。

### 3：构造函数

所谓“构造函数”，就是专门用来生成“对象”的函数。它提供模板，作为对象的基本结构。一个构造函数，可以生成多个对象，这些对象都有相同的结构。

构造函数是一个正常的函数，但是它的特征和用法与普通函数不一样。下面就是一个构造函数：

```
var Vehicle = function() {
  this.price = 1000;
};
```

上面代码中，Vehicle就是构造函数，它提供模板，用来生成车辆对象。

构造函数的最大特点就是，函数体内部使用了this关键字，代表了所要生成的对象实例。生成对象的时候，必需用new命令，调用Vehicle函数。

### 4：封装

所谓封装，是指面向对象的编程语言中隐藏了某一方法的内部逻辑或某一属性的值。对象只对外提供与其它对象交互所必需的接口，我们只需要关注如何使用，而不需要关心这些方法和属性究竟是什么。上一个例子中我们提到了芹菜，我们再向下细分，仍然可以将芹菜的器官作为划分对象的最小单位。它在发育果实时，身体中的某个器官会生成某种激素，用于加快果实的发育。果实作为一个对象，只需要使用激素，而不需要关心激素是如何产生的，更不会参与激素的产生。

于是，封装的优势就十分明显了：

对内部数据起到一定的保护作用
提高内聚，降低耦合（可以被多种对象复用）

### 5：继承

继承更像是一种家族关系。我们一般会把 B 从 A 获取了一些属性或方法的现象叫做“B 继承自 A”，那么 A 就相当于 B 的父级类，简称“父类”。同样地，在开篇的例子中，我们通过生物学中的概念理解类和对象：芹菜和胡萝卜同属于伞形科，但芹菜属于芹属，胡萝卜属于胡萝卜属，这两个属的共同父类是伞形科，也就是说它们都继承了伞形科的特征（叶片形状、花序、种子形态等）。同样地，比科更广的是目，所以目是科的父类，属于同一目的生物也都有一定的共同特征，它们的共同特征都来自于这个目所赋予的属性和方法。随着不断向父类追溯，父类会变得越来越抽象（共同特征越来越少）：生物学中父类的起点是界，动物界和植物界是占比最大的两个界，动物和植物的共同特征非常少（细胞层面以上的共同特征更是屈指可数）。

在编程语言中，继承也是如此。最抽象的类一定是继承的起点。在 JavaScript 中，继承的起点是 null， Object 直接继承自它。我们所熟知的继承，一般是从 Object 开始的。如果我们使用字面量模式创建一个对象，那么这个对象就继承自 Object。

### 6：多态

顾名思义，多态意味着某个方法在不同的条件下会选择不同的动作。多态性包括以下两种特性：

重写（Overwrite）：允许子类对方法的实现重写，但签名、形式参数列表和返回值类型都不能改变
重载（Override）：允许子类改变方法的形式参数列表、返回值类型，但不允许改变签名，在调用方法时，根据输入的形式参数选择对应的重载
回到之前的例子中：芹菜和胡萝卜的属性有一部分继承自伞形科，但是芹菜和胡萝卜最大的不同是胡萝卜会形成块状的橘红色根茎，而芹菜不会形成，但这种现象不允许输入的形式参数（土壤、光合作用、矿物质等）和返回值（根茎）是不同的。所以这两种植物在根茎基因表达上的不一致属于重写；在温度、阳光等条件适宜的情况下，芹菜会分化出花蕾，而恶劣条件下的芹菜可能一直都无法分化。这种现象则是重载。

### 7：对象的结构

对象中存储属性的区域实际有两个:
1.对象自身
直接通过对象所添加的属性,位于对象白身中
在类中通过=y的形式添加的属性,位对象自身中
2.原型(prototype
对象中还有一些内容,会存储到其他的对象里(惊型对象)
在对象中会有一个属性用来存储原型对象,这个属性叫做 proto
原型对象也负责为对象存储属性,
当我们访间对象中的属性时,会优先访问对象自的属性
对象白身不包含该属时,才会去原型对象中寻找
会添加到原型对象中的情况:
1在类中通过xxx()方式添加的方法,位于原型中
2.主动向原型中加的属性或方法

### 8：原型

访问一个对象的原型对象
对象。_ _ proto _ _
 object.getPrototypeof(对象)
原型对象中的数据:
			1.对象中的数据(性、方法等

2. constructor(对象的构造函
注意:
原型对象也有原型,这样就构成了一条原型链,根据对象的复杂积度不同,原型链的长度也不同
p对象的原型链:p对袋>原型-->原型-->null
obj对象的原型链:obj对-->原型-->null
原型链：
读取对象属性时,会优先对象自身属性,
如果对象中有,则使用,没去对象的原型中寻找
如果原型中有,则使用,没有则大原梨的原型中寻
直到找到 bjectbject对象的原型<的原型没有原型(为null)如果依然没有找到,返巨 undofined
一作用域链,是找变量的链,找不到会报错
一原型链,是找属性的链,找不到会返回undefined

所有的同类型对象它们的原对象都是同一个,
就意味,同类型对象的原型链是一样的
原型的作用:
原就相是一个公的区域,可以被所有该类实例访问,
可以将一个该类例中,所有的公共属性(方法储到原型中
这样我们需要建一个属性即可被所有实例访问

js中继承就是通过原型来实现的，当继承时，子类的原型就是一个父类的实例

在对象中有些值是对象独有的,像性(nae,age gender每个对象都应该有自己值
但是有些值对于每个对象来都是样的,各方法,对于一样的值没必要重发的创建

大部分情况下,我们是不需要修改原型对象
注意
千万不要通过类的实例去修改原型
1.通过一个对象影响所有同类对象,这么做不合适
2.修改原型先得创建实例,麻烦
3,危除
处理通过 proto能访问对象的原型外,
可以通过的 prototype性,大访问实例的原型
修改原型时,最好通过通过类去修改
好处:
1.改就是改所有实的原型
2,无需创建实例即可完成对类的修改
原则:
1.原型尽量不要手动改
2.要改也不要通过实例对象去改
3.通过类 prototype性去修改
4最好不要直接给 prototype去赋值



### 9：instanceof和hasOwnProperty

instanceof用来检查一个对象是否是个类的实例
 instanceof检查的是对象的原型上是否有该关实例
只要原型链上有该类实例,就会返回true
dog-> Animal的实例-> Object0实- bject原型

- Object是所有对象的原型,所以任何和对象和 objectinstanceof进行运算都会返回true


 in
使用in运算符检查属性时无论性在对象身还是在原型中,都会返回true
对象, hasOwnProperty(属性名)(不推使用
一用来检查一个对象的自身是否含有某个属生
 object. hasown(对象,属性名
用来检查一个对象的自身是否含有个属性

### 10：new运算符

new运算符是创建对象时要使用的运算符
使用new时,到底发生了哪些事情:
 https:  //developer. mozilla. org/en-us/docs/Web/ JavaScript/Reference/operators/new
当使用new去调用一个函数时,这个函数将会作为构造函数用,
使用new调用函数时,将会发生这些事;
1.创建一个普通的S对象(bject对象{}),为了方便,称其为新对象
2将构造函数的prototype属性设置为新对象的原型
3.使用实参来执行构造函数,并且将新对象设置为函数中的this
4.如果构造函数返回的是一个非原始值,则该值会作为new运算的返回值返回(千万不要这么做)
如果构造函数的返回值是一个原始值或者没有指定返回值,则新的对象将会作为返回值返回
通常不会为构造函数指定返回值

### 11：对象总结

面向对象本质就是,编写代码时所有的操作都是通过对象来进行的
面向对象的编程的步骤
	1.找对象
	2.搞对象
学习对象:
	1.明确这个对象代什么,有什么用
	2,如何获取到这个对象
	3.如何使用这个对象(对象一的属性方法
对象的分类
内建对象
	由ES标准定义的对象
 	object Function String Number..
宿主对象
	由浏览器提供的对象
 	-BOM, DOM
定义对象
	一由开发人员白己创建的对刻

## 八：数组(Array)

### 1：数组简介

数组也是一种复合数据类型,在数组可以存多个不同类型的数据
数组中存储的是有序的数据,数组中的每个数据都有一个一的
可以通过索引来操作取数据
数组中存储的数据叫元
引(index)是一组大于的整数
创建数组
	通过 Array()米创速数过,也可以过门创建数组
一向数组中添加元素
	语法
		数组[索引]一元素
读取数中的元素
	语法
	数组【索引】
如果读现了一个不存在的数组,不会报错而是返回 undefined

 Length
			获取数组的长度
			获取的实际值就是数的最大+1
			向数组最后添元素
					数组[数组, length]=元素
 			Length是可以改的

### 2：数组的遍历

任何类型的值都可以成为数中的元素

创建数组时尽量要确保数组中存储的数据的类型是相

遍历数组
遍历数组简理解就是获取数组的每个元素

### 3：for -of语句

forf语句可以用来遍历可选代对象
		语法
		for(变量	of	可选代的对像）{语句}
执行流程:
for-of的循环体执行数中有几个元素就会执行几次,
每次执行时都会将一个元素赋值给变量

### 4：数组的方法

Array. isArray()
			用来检查一个对象是否是数维
	 at（）
			可以根据索引获取数中的指定元素
			at可以接收负引作为参数
 	concat（）
			用来连接两个或多个数组
			非破坏方法,不会同响原数组面是返回一个新的数组
 indexof()
		获取元素在数组中第一次出现的索引
		参数:
			1.要查询的元素
			2.查询的其实位置
 lastIndexOf()
		获取元素在数组中最后一次出现的位置
		返回值:
			找到了则返回元素的索引,
			没有找到返回-1
 join()
		将一个数组中的元素连接为一个符串
		[孙悟空,“猪八戒,”沙和,沙尚一孙悟空,猪八戒,沙和尚,唐僧,沙和尚
		参数:
			指定一个字符串作为连接符
 slice()
		用来截取数组(非破坏性方法)
		参数:
			1.截取的起始位置(包括该位置
			2.截取的结束位置(不包括该位置)
				第二个参数可以省略不写,如果省略则会一直截取到最后
				一索引可以是负值
			如果将两个参数全都省略,则可以对数组进行浅拷贝(浅复制）



push（）

​	向数组的末尾添加一个或元素并返回新的长度

 pop（）
			删除返回数组的最后个元素
		 unshift(）
			向数组的开头个或多个元素,并返回新的长度
 		shift(）
			删除井返回数组的第个元素
		splice()
			可以删除、添加、插入、替换数组中的元素
			参数:
				1.删除的起始位置
				2.删除的数量
				3要插入的元素
				返回值：
					返回被删除的元素

### 5：对象的复制

如何去复制一个对象，复制必须要产生新的对象
	当调用slice时,会产生一个新的数组对象,从而完成对数组的复制

...	展开运算符
					可以将一个数组中的元素展开到另一个数组中或者作为函数的参数传递
					一通过它也可以对数组进行浅息制

对象的复制
 			Object. assign(目标对象,被复制的对象)
			将被制对象中的属性复制到目标对象里,并将目标对象返回
也可对使用展开运算符对对象进行复制

### 6：深拷贝和浅拷贝

浅拷贝(shallow copy）
				一通常对对象的拷都是浅拷贝
					浅拷贝顾名思义,只对对象的进行集制贝复制层
				如果对象中存储的数据是原值,那么贝的深浅是不重要
				浅拷贝只会对对象本身进行复制,不会复制对象中的属性(或元素)
	深拷贝(deep copy）
			深拷贝指不仅复制对象本身还复制对象中的属性和元素
			因为性能问题,通常情况不太使用深拷贝

### 7：数组去重

![image-20230112181005998](D:\typora破解\Typora\JavaScript笔记\JavaScript学习笔记.assets\image-20230112181005998.png)

![image-20230112181036713](D:\typora破解\Typora\JavaScript笔记\JavaScript学习笔记.assets\image-20230112181036713.png)

### 8:冒泡排序

![image-20230112181146707](D:\typora破解\Typora\JavaScript笔记\JavaScript学习笔记.assets\image-20230112181146707.png)

![image-20230112181325877](D:\typora破解\Typora\JavaScript笔记\JavaScript学习笔记.assets\image-20230112181325877.png)

优化：

![image-20230112181456475](D:\typora破解\Typora\JavaScript笔记\JavaScript学习笔记.assets\image-20230112181456475.png)

### 9：选择排序

![image-20230112181219278](D:\typora破解\Typora\JavaScript笔记\JavaScript学习笔记.assets\image-20230112181219278.png)

![image-20230112181605585](D:\typora破解\Typora\JavaScript笔记\JavaScript学习笔记.assets\image-20230112181605585.png)