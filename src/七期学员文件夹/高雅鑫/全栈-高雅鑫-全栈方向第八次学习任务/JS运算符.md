# 运算符

## 一.算数运算符

加法+ 减法- 乘法* 除法/ 指数运算符** 余数运算符% 自增（自减）++（--）

数值运算符+ 负数值运算符-

### 1.加法运算符

JavaScript 允许非数值的相加。

上面代码中，第一行是两个布尔值相加，第二行是数值与布尔值相加。这两种情况，布尔值都会自动转成数值，然后再相加。

比较特殊的是，如果是两个字符串相加，这时加法运算符会变成连接运算符，返回一个新的字符串，将两个原字符串连接在一起。

如果一个运算子是字符串，另一个运算子是非字符串，这时非字符串会转成字符串，再连接在一起。

加法运算符是在运行时决定，到底是执行相加，还是执行连接。也就是说，运算子的不同，导致了不同的语法行为，这种现象称为“重载”（overload）。由于加法运算符存在重载，可能执行两种运算，使用的时候必须很小心。

```javascript
'3' + 4 + 5 // "345"
3 + 4 + '5' // "75"
```

### 2.以外

除了加法运算符，其他算术运算符（比如减法、除法和乘法）都不会发生重载。它们的规则是：所有运算子一律转为数值，再进行相应的数学运算。

### 3.对象的相加

如果运算子是对象，必须先转成原始类型的值，然后再相加。

对象转成原始类型的值，规则如下。

首先，自动调用对象的`valueOf`方法。一般来说，对象的`valueOf`方法总是返回对象自身，这时再自动调用对象的`toString`方法，将其转为字符串。

```javascript
var obj = { p: 1 };
obj.valueOf() // { p: 1 }
```

```javascript
var obj = { p: 1 };
obj.valueOf().toString() // "[object Object]"
```

对象的`toString`方法默认返回`[object Object]`，所以就得到了最前面那个例子的结果。

知道了这个规则以后，就可以自己定义`valueOf`方法或`toString`方法，得到想要的结果。

```javascript
var obj = {
  valueOf: function () {
    return 1;
  }
};
obj + 2 // 3
```

```javascript
var obj = {
  toString: function () {
    return 'hello';
  }
};
obj + 2 // "hello2"j
```

上面代码中，对象`obj`的`toString`方法返回字符串`hello`。前面说过，只要有一个运算子是字符串，加法运算符就变成连接运算符，返回连接后的字符串。

这里有一个特例，如果运算子是一个`Date`对象的实例，那么会优先执行`toString`方法。

```javascript
var obj = new Date();
obj.valueOf = function () { return 1 };
obj.toString = function () { return 'hello' };
obj + 2 // "hello2"
```

上面代码中，对象`obj`是一个`Date`对象的实例，并且自定义了`valueOf`方法和`toString`方法，结果`toString`方法优先执行。

### 4.余数运算符

余数运算符（`%`）返回前一个运算子被后一个运算子除，所得的余数。

需要注意的是，运算结果的正负号由第一个运算子的正负号决定。

余数运算符还可以用于浮点数的运算。但是，由于浮点数不是精确的值，无法得到完全准确的结果。

### 5.自增和自减运算符

自增和自减运算符，是一元运算符，只需要一个运算子。它们的作用是将运算子首先转为数值，然后加上1或者减去1。它们会修改原始变量。

运算之后，变量的值发生变化，这种效应叫做运算的副作用（side effect）。自增和自减运算符是仅有的两个具有副作用的运算符，其他运算符都不会改变变量的值。

自增和自减运算符有一个需要注意的地方，就是放在变量之后，会先返回变量操作前的值，再进行自增/自减操作；放在变量之前，会先进行自增/自减操作，再返回变量操作后的值。

### 6.数值运算符，负数值运算符

数值运算符（`+`）同样使用加号，但它是一元运算符（只需要一个操作数），而加法运算符是二元运算符（需要两个操作数）。

数值运算符的作用在于可以将任何值转为数值（与`Number`函数的作用相同）。

上面代码表示，非数值经过数值运算符以后，都变成了数值（最后一行`NaN`也是数值）负数值运算符（`-`），也同样具有将一个值转为数值的功能，只不过得到的值正负相反。连用两个负数值运算符，等同于数值运算符。

数值运算符号和负数值运算符，都会返回一个新的值，而不会改变原始变量的值。

### 7.指数运算符

指数运算符（`**`）完成指数运算，前一个运算子是底数，后一个运算子是指数。

```javascript
2 ** 4 // 16
```

注意，**指数运算符是右结合，而不是左结合。即多个指数运算符连用时，先进行最右边的计算。**

```javascript
// 相当于 2 ** (3 ** 2)
2 ** 3 ** 2
// 512
```

### 8.赋值运算符

赋值运算符（Assignment Operators）用于给变量赋值。

最常见的赋值运算符，当然就是等号（`=`）。

赋值运算符还可以与其他运算符结合，形成变体。下面是与算术运算符的结合。

```javascript
// 等同于 x = x + y
x += y
// 等同于 x = x - y
x -= y
// 等同于 x = x * y
x *= y
// 等同于 x = x / y
x /= y
// 等同于 x = x % y
x %= y
// 等同于 x = x ** y
x **= y
```

下面是与位运算符的结合

```javascript
// 等同于 x = x >> y
x >>= y
// 等同于 x = x << y
x <<= y
// 等同于 x = x >>> y
x >>>= y
// 等同于 x = x & y
x &= y
// 等同于 x = x | y
x |= y
// 等同于 x = x ^ y
x ^= y
```

这些复合的赋值运算符，都是先进行指定运算，然后将得到值返回给左边的变量。

## 二.比较运算符

大于> (=) 小于<(=)  ==相等运算符 ===严格相等运算符  !=不相等 !==严格不相等运算符

这八个比较运算符分成两类：相等比较和非相等比较

### 1.非相等运算符：字符串的比较

字符串按照字典顺序进行比较。

JavaScript 引擎内部首先比较首字符的 Unicode 码点。如果相等，再比较第二个字符的 Unicode 码点，以此类推。

由于所有字符都有 Unicode 码点，因此汉字也可以比较。

### 2.非相等运算符：非字符串的比较

如果两个运算子之中，至少有一个不是字符串，需要分成以下两种情况。

#### **（1）原始类型值**

如果两个运算子都是原始类型的值，则是先转成数值再比较。****

![image-20230110160113644](https://tallgao.oss-cn-beijing.aliyuncs.com/image-20230110160113644.png)

上面代码中，字符串和布尔值都会先转成数值，再进行比较。

**这里需要注意与`NaN`的比较。任何值（包括`NaN`本身）与`NaN`比较，返回的都是`false`。**

#### （2）对象

如果运算子是对象，会转为原始类型的值，再进行比较。

对象转换成原始类型的值，算法是先调用`valueOf`方法；如果返回的还是对象，再接着调用`toString`方法

![image-20230110160813694](https://tallgao.oss-cn-beijing.aliyuncs.com/image-20230110160813694.png)

`undefined`和`null`与自身严格相等。

由于变量声明后默认值是`undefined`，因此两个只声明未赋值的变量是相等的

### 3.严格相等运算符

JavaScript 提供两种相等运算符：`==`和`===`。

简单说，它们的区别是相等运算符（`==`）比较两个值是否相等，严格相等运算符（`===`）比较它们是否为“同一个值”。如果两个值不是同一类型，严格相等运算符（`===`）直接返回`false`，而相等运算符（`==`）会将它们转换成同一个类型，再用严格相等运算符进行比较。

**（1）不同类型的值**

如果两个值的类型不同，直接返回`false`。

**（2）同一类的原始类型值**

同一类型的原始类型的值（数值、字符串、布尔值）比较时，值相同就返回`true`，值不同就返回`false`。

需要注意的是，`NaN`与任何值都不相等（包括自身）。另外，正`0`等于负`0`。

**（3）复合类型值**

两个复合类型（对象、数组、函数）的数据比较时，不是比较它们的值是否相等，而是比较它们是否指向同一个地址。

```javascript
{} === {} // false
[] === [] // false
(function () {} === function () {}) // false
```

严格相等运算比较的是，**它们是否引用同一个内存地址，**而运算符两边的空对象、空数组、空函数的值，都存放在不同的内存地址，结果当然是`false`。

### 4.严格不相等运算符

严格相等运算符有一个对应的“严格不相等运算符”（`!==`），它的算法就是先求严格相等运算符的结果，然后返回相反值。

### 5.相等运算符

相等运算符用来比较相同类型的数据时，与严格相等运算符完全一样。

比较不同类型的数据时，相等运算符会先将数据进行类型转换，然后再用严格相等运算符比较。下面分成四种情况，讨论不同类型的值互相比较的规则。

#### **（1）原始类型值**

原始类型的值会转换成数值再进行比较。

![image-20230110163737750](https://tallgao.oss-cn-beijing.aliyuncs.com/image-20230110163737750.png)

![image-20230110163807220](https://tallgao.oss-cn-beijing.aliyuncs.com/image-20230110163807220.png)

#### **（2）对象与原始类型值比较**

对象（这里指广义的对象，包括数组和函数）与原始类型的值比较时，对象转换成原始类型的值，再进行比较。

![image-20230110164640182](https://tallgao.oss-cn-beijing.aliyuncs.com/image-20230110164640182.png)

`undefined`和`null`与其他类型的值比较时，结果都为`false`，它们互相比较时结果为`true`。

#### （3）相等运算符的缺点

相等运算符隐藏的类型转换，会带来一些违反直觉的结果。

![image-20230110164847166](https://tallgao.oss-cn-beijing.aliyuncs.com/image-20230110164847166.png)

## 三.布尔运算符

取反运算符：！

且：&&

或：||

三元运算符 ：  ?:

### 1.取反运算符（!）

取反运算符是一个感叹号，用于将布尔值变为相反值，即`true`变成`false`，`false`变成`true`。

对于非布尔值，取反运算符会将其转为布尔值。可以这样记忆，以下六个值取反后为`true`，其他值都为`false`。

(undefined null false 0 NaN  '')

如果对一个值连续做两次取反运算，等于将其转为对应的布尔值,所以，两次取反就是将一个值转为布尔值的简便写法。

### 2.且运算符（&&）

且运算符（`&&`）往往用于多个表达式的求值。

如果第一个运算子的布尔值为`true`，则返回第二个运算子的值（注意是值，不是布尔值）；如果第一个运算子的布尔值为`false`，则直接返回第一个运算子的值，且不再对第二个运算子求值。

### 3.或运算符（||）

或运算符（`||`）也用于多个表达式的求值。它的运算规则是：如果第一个运算子的布尔值为`true`，则返回第一个运算子的值，且不再对第二个运算子求值；如果第一个运算子的布尔值为`false`，则返回第二个运算子的值。

### 4.三元条件运算符（?:）

三元条件运算符由问号（?）和冒号（:）组成，分隔三个表达式。它是 JavaScript 语言唯一一个需要三个运算子的运算符。如果第一个表达式的布尔值为`true`，则返回第二个表达式的值，否则返回第三个表达式的值。

```javascript
't' ? 'hello' : 'world' // "hello"
0 ? 'hello' : 'world' // "world"
```

if...else是语句，没有返回值；三元条件表达式是表达式，具有返回值。所以，在需要返回值的场合，只能使用三元条件表达式，而不能使用if..else.

