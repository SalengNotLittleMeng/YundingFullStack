# JS数据类型

## 一.概述

js中的数据类型包括：**数值，字符串，布尔值，undefined,null,对象**（各种值组成的集合）（对象包括对象 数组 函数）

## 二.数值

### 1.概述

JavaScript 内部，所有数字都是以64位浮点数形式储存，即使整数也是如此。所以，`1`与`1.0`是相同的，是同一个数。但某些运算只有整数才能完成，此时 JavaScript 会自动把64位浮点数，转成32位整数，然后再进行运算

由于浮点数不是精确的值，所以涉及小数的比较和运算要特别小心。大于2的53次方的数值，都无法保持精度。简单的法则就是，JavaScript **对15位的十进制数都可以精确处理**

**大于2的53次方以后，多出来的有效数字（最后三位的`111`）都会无法保存，变成0。**

### 2.数值范围

如果一个数大于等于2的1024次方，那么就会发生“正向溢出”，即 JavaScript 无法表示这么大的数，这时就会返回Infinity。

如果一个数小于等于2的-1075次方（指数部分最小值-1023，再加上小数部分的52位），那么就会发生为“负向溢出”，即 JavaScript 无法表示这么小的数，这时会直接返回0。

### 3.表示方法

JavaScript 的数值有多种表示方法，可以用字面形式直接表示，比如`35`（十进制）和`0xFF`（十六进制）。

科学计数法允许字母`e`或`E`的后面，跟着一个整数，表示这个数值的指数部分。

JavaScript 会自动将数值转为科学计数法表示，其他情况都采用字面形式直接表示。

### 4.数值的进制

使用字面量（literal）直接表示一个数值时，JavaScript 对整数提供四种进制的表示方法：十进制、十六进制、八进制、二进制。

- 十进制：没有前导0的数值。
- 八进制：有前缀`0o`或`0O`的数值，或者有前导0、且只用到0-7的八个阿拉伯数字的数值。
- 十六进制：有前缀`0x`或`0X`的数值。
- 二进制：有前缀`0b`或`0B`的数值。

注意：

默认情况下，JavaScript 内部会自动将八进制、十六进制、二进制转为十进制。

通常来说，有前导0的数值会被视为八进制，但是如果前导0后面有数字`8`和`9`，则该数值被视为十进制。

前导0表示八进制，处理时很容易造成混乱。ES5 的严格模式和 ES6，**已经废除了这种表示法**

### 5.特殊的数值

#### 正零和负零

JavaScript 的64位浮点数之中，有一个二进制位是符号位。这意味着，任何一个数都有一个对应的负值，就连`0`也不例外

JavaScript 内部实际上存在2个`0`：一个是`+0`，一个是`-0`，区别就是64位浮点数表示法的符号位不同。它们是等价的。

除了这种情况：“`+0`或`-0`当作分母，返回的值是不相等的。因为除以正零得到`+Infinity`，除以负零得到`-Infinity`，这两者是不相等的”  其他时候正负0是相等的。

#### NaN(非数字)

##### 含义

`NaN`是 JavaScript 的特殊值，表示“非数字”（Not a Number），主要出现在将字符串解析成数字出错的场合。

```javascript
5 - 'x' // NaN
```

上面代码运行时，会自动将字符串`x`转为数值，但是由于`x`不是数值，所以最后得到结果为`NaN`，表示它是“非数字”（`NaN`）。

另外，一些数学函数的运算结果会出现`NaN`。

**`0`除以`0`也会得到`NaN`。**

需要注意的是**，`NaN`不是独立的数据类型，而是一个特殊数值，****它的数据类型依然属于`Number`**,使用`typeof`运算符可以看得很清楚。

##### 运算规则

`NaN`不等于任何值，包括它本身。

```
NaN === NaN // false
```

数组的`indexOf`方法内部使用的是严格相等运算符，所以该方法对`NaN`不成立。

```
[NaN].indexOf(NaN) // -1
```

`NaN`在布尔运算时被当作`false`。

```
Boolean(NaN) // false
```

`NaN`与任何数（包括它自己）的运算，得到的都是`NaN`。

#### Infinity(无穷)

##### 含义

Infinity表示“无穷”，用来表示两种场景。一种是一个正的数值太大，或一个负的数值太小，无法表示；另一种是非0数值除以0，得到Infinity。

Infinity有正负之分，Infinity表示正的无穷，-Infinity表示负的无穷。

零正数除以`-0`，会得到`-Infinity`，负数除以-0，会得到Infinity。

Infinity大于一切数值（除了NaN），-Infinity小于一切数值（除了`NaN`）。

Infinity与Nan比较，总是返回false。

##### 运算规则

Infinity的四则运算，**符合无穷的数学计算规则**

0乘以Infinity，返回NaN；0除以Infinity，返回0；Infinity除以0，返回Infinity。

Infinity加上或乘以Infinity，返回的还是Infinity。

Infinity减去或除以Infinity，得到NaN。

Infinity与null计算时，null会转成0，等同于与0的计算

Infinity与undefined计算，返回的都是NaN。

### 6.相关全局方法

#### 1.parseInt()

`parseInt`方法用于将字符串转为整数。**如果字符串头部有空格，空格会被自动去除。如果`parseInt`的参数不是字符串，则会先转为字符串再转换**

**字符串转为整数的时候，是一个个字符依次转换，如果遇到不能转为数字的字符，就不再进行下去，返回已经转好的部分。**

**如果字符串的第一个字符不能转化为数字（后面跟着数字的正负号除外），返回NaN.**

parseInt的返回值只有两种可能，要么是一个十进制整数，要么是NaN。

**如果字符串以0x或0X开头，parseInt会将其按照十六进制数解析。**

**如果字符串以`0`开头，将其按照10进制解析。**

对于那些会自动转为科学计数法的数字，parseInt会将科学计数法的表示方法视为字符串，因此导致一些奇怪的结果。

**进制转化**

parseInt方法还可以接受第二个参数（2到36之间），表示被解析的值的进制，返回该值对应的十进制数。默认情况下，parseInt的第二个参数为10，即默认是十进制转十进制。

```javascript
parseInt('1000', 8) // 512
```

如果第二个参数不是数值，会被自动转为一个整数。这个整数只有在2到36之间，才能得到有意义的结果，超出这个范围，则返回NaN。如果第二个参数是0、undefined和null，则直接忽略。

#### 2.parseFloat()

方法用于将一个字符串转为浮点数。

```js
parseFloat('3.14') // 3.14
```

如果字符串符合科学计数法，则会进行相应的转换。

```javascript
parseFloat('314e-2') // 3.14parseFloat('0.0314E+2') // 3.14
```

如果字符串包含不能转为浮点数的字符，则不再进行往后转换，返回已经转好的部分。

parseFloat**方法会自动过滤字符串前导的空格**。

**如果参数不是字符串，或者字符串的第一个字符不能转化为浮点数，则返回NaN。**

parseFloat会将空字符串转为NaN。

这些特点使得parseFloat的转换结果不同于Number函数。

#### 3.isNaN()

**`isNaN`方法可以用来判断一个值是否为`NaN`。**

`isNaN`只对数值有效，如果传入其他值，会被先转成数值。比如，传入字符串的时候，字符串会被先转成`NaN`，所以最后返回`true`，这一点要特别引起注意。也就是说，`isNaN`为`true`的值，有可能不是`NaN`，而是一个字符串。对于对象和数组，`isNaN`也返回`true`。

但是，对于空数组和只有一个数值成员的数组，`isNaN`返回`false`。

使用`isNaN`之前，最好判断一下数据类型。

```js
 function myIsNaN(value) {  return typeof value === 'number' && isNaN(value);}
```

判断`NaN`更可靠的方法是，**利用`NaN`为唯一不等于自身的值的**这个特点，进行判断。

```javascript
 function myIsNaN(value) {  return value !== value;}
```

#### 4.isFinite()

isFinite方法返回一个布尔值，表示某个值是否为正常的数值。

除了Infinity、-Infinity、NaN和undefined这几个值会返回false，isFinite对于其他的数值都会返回true。

## 三.字符串

### 1.定义

字符串就是零个或多个排在一起的字符，放在单引号或双引号之中。

单引号字符串的内部，可以使用双引号。双引号字符串的内部，可以使用单引号。

如果要在单引号字符串的内部，使用单引号，就必须在内部的单引号前面加上反斜杠，用来转义。双引号字符串内部使用双引号，也是如此。

 **HTML 语言的属性值使用双引号，约定 JavaScript 语言的字符串只使用单引号，本教程遵守这个约定。**

字符串默认只能写在一行内，分成多行将会报错。

如果长字符串必须分成多行，可以在每一行的尾部使用反斜杠。

```js
 var longString = 'Long \long \long \string';
```

上面代码表示，加了反斜杠以后，原来写在一行的字符串，可以分成多行书写。但是，输出的时候还是单行，效果与写在同一行完全一样。**注意，反斜杠的后面必须是换行符，而不能有其他字符（比如空格），否则会报错。**

连接运算符（`+`）可以连接多个单行字符串，将长字符串拆成多行书写，输出的时候也是单行。

```js
 var longString = 'Long '  + 'long '  + 'long '  + 'string';
```

如果想输出多行字符串，有一种利用多行注释的变通方法

```javascript
(function () { /*
line 1
line 2
line 3
*/}).toString().split('\n').slice(1, -1).join('\n')
 // "line 1
// line 2
// line 3
```

### 2.转义

反斜杠（\）在字符串内有特殊含义，用来表示一些特殊字符，所以又称为转义符。

- `\0` ：null（`\u0000`）
- `\b` ：后退键（`\u0008`）
- `\f` ：换页符（`\u000C`）
- `\n` ：换行符（`\u000A`）
- `\r` ：回车键（`\u000D`）
- `\t` ：制表符（`\u0009`）
- `\v` ：垂直制表符（`\u000B`）
- `\'` ：单引号（`\u0027`）
- `\"` ：双引号（`\u0022`）
- `\\` ：反斜杠（`\u005C`）

上面这些字符前面加上反斜杠，都表示特殊含义。

上面代码中，`\n`表示换行，输出的时候就分成了两行。

反斜杠还有三种特殊用法。

（1）`\HHH`

反斜杠后面紧跟三个八进制数（`000`到`377`），代表一个字符。`HHH`对应该字符的 Unicode 码点，比如`\251`表示版权符号。显然，这种方法只能输出256种字符。

（2）`\xHH`

`\x`后面紧跟两个十六进制数（`00`到`FF`），代表一个字符。`HH`对应该字符的 Unicode 码点，比如`\xA9`表示版权符号。这种方法也只能输出256种字符。

（3）`\uXXXX`

`\u`后面紧跟四个十六进制数（`0000`到`FFFF`），代表一个字符。`XXXX`对应该字符的 Unicode 码点，比如`\u00A9`表示版权符号。

**如果在非特殊字符前面使用反斜杠，则反斜杠会被省略。**

**如果字符串的正常内容之中，需要包含反斜杠，则反斜杠前面需要再加一个反斜杠，用来对自身转义。**

### 3.字符串与数组

**字符串可以被视为字符数组，因此可以使用数组的方括号运算符，用来返回某个位置的字符（位置编号从0开始）。**

1. ```javascript
   var s = 'hello';`
   s[0] // "h"`
   s[1] // "e"`
   s[4] // "o"`
   
   // 直接对字符串使用方括号运算符`
   'hello'[1] // "e"
   ```

如果方括号中的数字超过字符串的长度，或者方括号中根本不是数字，则返回`undefined`。

但是，字符串与数组的相似性仅此而已。实际上，无法改变字符串之中的单个字符。

### 4.属性

length属性返回字符串的长度，该属性也是无法改变的。

### 5.方法

本质：字符串本质就是一个字符数组

方法都是非破坏性的

##### str.at()（实验方法）

根据索引获取字符，可以接受负索引

##### str.charAt()

按照索引获取字符

##### str.concat()

用来连接两个或多个字符串

##### str.includes()

用来检查字符串中是否包含某个内容，有返回true 没有返回false

第一个参数是，检查的内容，第二个是起始位置

##### str.indexOf()  str.lastIndexOf()

查询字符串中是否包含某个内容  返回其出现的位置

##### str.startWith()  str.endWith()

检查一个字符串是否以指定内容开头/结尾

##### str.padStart()  str.padEnd()

通过添加指定的内容，使字符串保持某个长度

##### str.replace("里面的内容","要换的内容")

用指定内容替换原先的内容

##### str.slice()

对字符串进行切片

##### str.subsring(a,b)

截取字符串从a开始截取 截取b个

##### str.split()

用来把一个字符串拆成一个数组

##### str.toLowerCase()   str.toLowerCase()

将字符串转化为大小写

##### str.trimStart()   str.trimEnd()  str.trim()

去除前面的空格 后面的空格

## 四.布尔值与null和undefined

#### 1.布尔值

布尔值代表“真”和“假”两个状态。“真”用关键字`true`表示，“假”用关键字`false`表示。布尔值只有这两个值。

下列运算符会返回布尔值：

- 前置逻辑运算符： `!` (Not)
- 相等运算符：`===`，`!==`，`==`，`!=`
- 比较运算符：`>`，`>=`，`<`，`<=`

如果 JavaScript 预期某个位置应该是布尔值，会将该位置上现有的值自动转为布尔值。转换规则是除了下面六个值被转为`false`，其他值都视为`true`。

- `undefined`
- `null`
- `false`
- `0`
- `NaN`
- `""`或`''`（空字符串）

注意，空数组（`[]`）和空对象（`{}`）对应的布尔值，都是`true`。

#### 2.null与undefined

`null`与`undefined`都可以表示“没有”，含义非常相似。将一个变量赋值为`undefined`或`null`，老实说，语法效果几乎没区别。

在`if`语句中，它们都会被自动转为`false`，相等运算符（`==`）甚至直接报告两者相等。

`null`表示空值，即该处的值现在为空。调用函数时，某个参数未设置任何值，这时就可以传入`null`，表示该参数为空。比如，某个函数接受引擎抛出的错误作为参数，如果运行过程中未出错，那么这个参数就会传入`null`，表示未发生错误。

`undefined`表示“未定义”

## 五.对象

对象（object）是 JavaScript 语言的核心概念，也是最重要的数据类型。

什么是对象？简单说，对象就是一组“键值对”（key-value）的集合，是一种无序的复合数据集合。

```javascript
var obj = {
  foo: 'Hello',
  bar: 'World'
};
```

上面代码中，大括号就定义了一个对象，它被赋值给变量`obj`，所以变量`obj`就指向一个对象。该对象内部包含两个键值对（又称为两个“成员”），第一个键值对是`foo: 'Hello'`，其中`foo`是“键名”（成员的名称），字符串`Hello`是“键值”（成员的值）。键名与键值之间用冒号分隔。第二个键值对是`bar: 'World'`，`bar`是键名，`World`是键值。两个键值对之间用逗号分隔。

### windows对象

在浏览器中，浏览器为我们提供了一个window对象，可以直接访问。

windows对象代表的是浏览器窗口，通过该对象可以对浏览器窗口进行各种操作，除此之外，window对象还负责JS中的内置对象和浏览器的宿主对象，

window对象的属性可以通过window对象访问，也可以直接访问。

var用来声明变量，作用和let相同，但var不具有块作用域，在全局中使用var声明的变量，都会作为window的方法保存。

使用function声明的函数，都会作为window的方法保存，使用let声明的变量不会存储在window，而是一个秘密的小地方。

### 键名

对象的所有键名都是字符串（ES6 又引入了 Symbol 值也可以作为键名），所以加不加引号都可以。上面的代码也可以写成下面这样。

如果键名是数值，会被自动转为字符串。

如果键名不符合标识名的条件（比如第一个字符为数字，或者含有空格或运算符），且也不是数字，则必须加上引号，否则会报错

对象的每一个键名又称为“属性”（property），它的“键值”可以是任何数据类型。如果一个属性的值为函数，通常把这个属性称为“方法”，它可以像函数那样调用。

上面代码中，对象`obj`的属性`p`，就指向一个函数。

如果属性的值还是一个对象，就形成了链式引用。

```javascript
var o1 = {};
var o2 = { bar: 'hello' };
o1.foo = o2;
o1.foo.bar // "hello"
```

上面代码中，对象`o1`的属性`foo`指向对象`o2`，就可以链式引用`o2`的属性。

对象的属性之间用逗号分隔，最后一个属性后面可以加逗号（trailing comma），也可以不加。

属性可以动态创建，不必在对象声明时就指定。

### 引用

如果不同的变量名指向同一个对象，那么它们都是这个对象的引用，也就是说指向同一个内存地址。修改其中一个变量，会影响到其他所有变量。

```javascript
var o1 = {};
var o2 = o1;
o1.a = 1;
o2.a // 1
o2.b = 2;
o1.b // 2
```

上面代码中，`o1`和`o2`指向同一个对象，因此为其中任何一个变量添加属性，另一个变量都可以读写该属性。

此时，如果取消某一个变量对于原对象的引用，不会影响到另一个变量。

```javascript
var o1 = {};
var o2 = o1;
o1 = 1;
o2 // {}
```

是，这种引用只局限于对象，如果两个变量指向同一个原始类型的值。那么，变量这时都是值的拷贝。**并不是指向同一个内存地址。**

#### 表达式还是语句？

对象采用大括号表示，这导致了一个问题：如果行首是一个大括号，它到底是表达式还是语句？

```
{ foo: 123 }
```

JavaScript 引擎的做法是，如果遇到这种情况，无法确定是对象还是代码块，一律解释为代码块。

```javascript
 { console.log(123) } // 123
```

如果要解释为对象，最好在大括号前加上圆括号。因为圆括号的里面，只能是表达式，所以确保大括号只能解释为对象。

如果要解释为对象，最好在大括号前加上圆括号。因为圆括号的里面，只能是表达式，所以确保大括号只能解释为对象。

上面代码中，如果没有圆括号，`eval`将其理解为一个代码块；加上圆括号以后，就理解成一个对象。

### 属性的操作

#### 属性的读取

读取对象的属性，有两种方法，一种是使用点运算符，还有一种是使用方括号运算符。

```javascript
var obj = {
  p: 'Hello World'
};
obj.p // "Hello World"
obj['p'] // "Hello World"
```

请注意，如果使用方括号运算符**，键名必须放在引号里面，否则会被当作变量处理。**

```javascript
var foo = 'bar';
var obj = {
  foo: 1,
  bar: 2
};
obj.foo  // 1
obj[foo]  // 2
```

上面代码中，引用对象`obj`的`foo`属性时，如果使用点运算符，`foo`就是字符串；如果使用方括号运算符，但是不使用引号，那么`foo`就是一个变量，指向字符串`bar`。

**方括号运算符内部还可以使用表达式。**

数字键可以不加引号，因为会自动转成字符串。

注意，数值键名不能使用点运算符（因为会被当成小数点），只能使用方括号运算符。

```javascript
var obj = {
  123: 'hello world'
};
obj.123 // 报错
obj[123] // "hello world"
```

#### 属性的赋值

点运算符和方括号运算符，不仅可以用来读取值，还可以用来赋值。

```javascript
var obj = {};

obj.foo = 'Hello';
obj['bar'] = 'World';
```

上面代码中，分别使用点运算符和方括号运算符，对属性赋值。

JavaScript 允许属性的“后绑定”，也就是说，你可以在任意时刻新增属性，没必要在定义对象的时候，就定义好属性。

#### 属性的查看

查看一个对象本身的所有属性，可以使用`Object.keys`方法。

#### 属性的删除：delete 命令

`delete`命令用于删除对象的属性，删除成功后返回`true`。

```javascript
var obj = { p: 1 };
Object.keys(obj) // ["p"]
delete obj.p // true
obj.p // undefined
Object.keys(obj) // []
```

上面代码中，`delete`命令删除对象`obj`的`p`属性。删除后，再读取`p`属性就会返回`undefined`，而且`Object.keys`方法的返回值也不再包括该属性。

注意，删除一个不存在的属性，`delete`不报错，而且返回`true`。

上面代码中，对象`obj`并没有`p`属性，但是`delete`命令照样返回`true`。因此，不能根据`delete`命令的结果，认定某个属性是存在的。

只有一种情况，`delete`命令会返回`false`，那就是该属性存在，且不得删除。

**另外，需要注意的是，`delete`命令只能删除对象本身的属性，无法删除继承的属性**

#### 属性是否存在：in 运算符

`in`运算符用于检查对象是否包含某个属性（注意，检查的是键名，不是键值），如果包含就返回`true`，否则返回`false`。它的左边是一个字符串，表示属性名，右边是一个对象

```javascript
var obj = { p: 1 };
'p' in obj // true
'toString' in obj // true
```

`in`运算符的一个问题是，它不能识别哪些属性是对象自身的，哪些属性是继承的。就像上面代码中，对象`obj`本身并没有`toString`属性，但是`in`运算符会返回`true`，因为这个属性是继承的。

这时，可以使用对象的`hasOwnProperty`方法判断一下，是否为对象自身的属性。

```javascript
var obj = {};
if ('toString' in obj) {
  console.log(obj.hasOwnProperty('toString')) // false
}
```

#### 属性的遍历：for…in 循环

`for...in`循环用来遍历一个对象的全部属性。

`for...in`循环有两个使用注意点。

- 它遍历的是对象所有可遍历（enumerable）的属性，会跳过不可遍历的属性。
- 它不仅遍历对象自身的属性，还遍历继承的属性。

如果继承的属性是可遍历的，那么就会被`for...in`循环遍历到。但是，一般情况下，都是只想遍历对象自身的属性，所以使用`for...in`的时候，应该结合使用`hasOwnProperty`方法，在循环内部判断一下，某个属性是否为对象自身的属性。

```javascript
var person = { name: '老张' };
for (var key in person) {
  if (person.hasOwnProperty(key)) {
    console.log(key);
  }
}
// name
```

#### 对象的解构

解构 是 JavaScript 中将数组中的值或对象中的属性**解压缩为不同的变量**的方式。

{}表示的是代码块

![image-20230106084936280](https://tallgao.oss-cn-beijing.aliyuncs.com/image-20230106084936280.png)

把a,b,c由他们赋值

冒号后面的内容才是变量

![image-20230110111539347](C:\Users\飞飞飞飞\AppData\Roaming\Typora\typora-user-images\image-20230110111539347.png)

## 六.数组

### 定义

数组（array）是按次序排列的一组值。每个值的位置都有编号（从0开始），整个数组用方括号表示。

1. `var arr = ['a', 'b', 'c'];`

除了在定义时赋值，数组也可以先定义后赋值。

任何类型的数据，都可以放入数组。

如果数组的元素还是数组，就形成了多维数组

### 数组的本质

本质上，数组属于一种特殊的对象。`typeof`运算符会返回数组的类型是`object`。

数组的特殊性体现在，它的键名是按次序排列的一组整数（0，1，2…）。

由于数组成员的键名是固定的（默认总是0、1、2…），因此数组不用为每个元素指定键名，而对象的每个成员都必须指定键名。JavaScript 语言规定，对象的键名一律为字符串，所以，数组的键名其实也是字符串。之所以可以用数值读取，是因为非字符串的键名会被转为字符串。

对象有两种读取成员的方法：点结构（`object.key`）和方括号结构（`object[key]`）。但是，对于数值的键名，不能使用点结构。

面代码中，`arr.0`的写法不合法，因为单独的数值不能作为标识符（identifier）。所以，数组成员只能用方括号`arr[0]`表示（方括号是运算符，可以接受数值）。

### length 属性

数组的`length`属性，返回数组的成员数量。

只要是数组，就一定有`length`属性。该属性是一个动态的值，等于键名中的最大整数加上`1`。

另外，这也表明数组是一种动态的数据结构，可以随时增减数组的成员。

**`length`属性是可写的。如果人为设置一个小于当前成员个数的值，该数组的成员数量会自动减少到`length`设置的值。**

清空数组的一个有效方法，就是将`length`属性设为0。

```javascript
var arr = [ 'a', 'b', 'c' ];
arr.length = 0;
arr // []
```

如果人为设置`length`大于当前元素个数，则数组的成员数量会增加到这个值，新增的位置都是空位。

上面代码表示，当`length`属性设为大于数组个数时，读取新增的位置都会返回`undefined`。

如果人为设置`length`为不合法的值，JavaScript 会报错。

值得注意的是，由于数组本质上是一种对象，所以可以为数组添加属性，但是这不影响`length`属性的值。

如果数组的键名是添加超出范围的数值，该键名会自动转为字符串。

### in 运算符

检查某个键名是否存在的运算符`in`，适用于对象，也适用于数组。**

```javascript
var arr = [ 'a', 'b', 'c' ];
2 in arr  // true
'2' in arr // true
4 in arr // false
```

**注意，如果数组的某个位置是空位，`in`运算符返回`false`。******

### for…in 循环和数组的遍历

`for...in`循环不仅可以遍历对象，也可以遍历数组，毕竟数组只是一种特殊对象。

```javascript
var a = [1, 2, 3];
for (var i in a) {
  console.log(a[i]);
}
// 1
// 2
// 3
```

但是，`for...in`不仅会遍历数组所有的数字键，还会遍历非数字键。

不推荐使用`for...in`遍历数组。

数组的遍历可以考虑使用`for`循环或`while`循环。

```javascript
var a = [1, 2, 3];
// for循环
for(var i = 0; i < a.length; i++) {
  console.log(a[i]);
}
// while循环
var i = 0;
while (i < a.length) {
  console.log(a[i]);
  i++;
}
var l = a.length;
while (l--) {
  console.log(a[l]);
}
```

数组的`forEach`方法，也可以用来遍历数组

当数组的某个位置是空元素，即两个逗号之间没有任何值，我们称该数组存在空位（hole）。

上面代码表明，数组的空位不影响`length`属性。

需要注意的是，如果最后一个元素后面有逗号，并不会产生空位。也就是说，有没有这个逗号，结果都是一样的

数组的空位是可以读取的，返回`undefined`

使用`delete`命令删除一个数组成员，会形成空位，并且不会影响`length`属性。

也就是说，`length`属性不过滤空位。所以，使用`length`属性进行数组遍历，一定要非常小心。

**数组的某个位置是空位，与某个位置是`undefined`，是不一样的。如果是空位，使用数组的`forEach`方法、`for...in`结构、以及`Object.keys`方法进行遍历，空位都会被跳过。**

**如果某个位置是`undefined`，遍历的时候就不会被跳过。**

**空位就是数组没有这个元素，所以不会被遍历到，而`undefined`则表示数组有这个元素，值是`undefined`，所以遍历不会跳过。**

### 类似数组的对象

如果一个对象的所有键名都是正整数或零，并且有`length`属性，那么这个对象就很像数组，语法上称为“类似数组的对象”（array-like object）。

类似数组的对象”并不是数组，因为它们不具备数组特有的方法。对象`obj`没有数组的`push`方法，使用该方法就会报错。

类似数组的对象”的根本特征，就是具有`length`属性。只要有`length`属性，就可以认为这个对象类似于数组。但是有一个问题，**这种`length`属性不是动态值，不会随着成员的变化而变化。**

典型的“类似数组的对象”是函数的`arguments`对象，以及大多数 DOM 元素集，还有字符串。

```javascript
// arguments对象
function args() { return arguments }
var arrayLike = args('a', 'b');
arrayLike[0] // 'a'
arrayLike.length // 2
arrayLike instanceof Array // false
// DOM元素集
var elts = document.getElementsByTagName('h3');
elts.length // 3
elts instanceof Array // false
// 字符串
'abc'[1] // 'b'
'abc'.length // 3
'abc' instanceof Array // false
```

上面代码包含三个例子，它们都不是数组（`instanceof`运算符返回`false`），但是看上去都非常像数组。

数组的`slice`方法可以将“类似数组的对象”变成真正的数组。

```javascript
var arr = Array.prototype.slice.call(arrayLike);
```

除了转为真正的数组，“类似数组的对象”还有一个办法可以使用数组的方法，就是通过`call()`把数组的方法放到对象上面。

```javascript
function print(value, index) {
  console.log(index + ' : ' + value);
}
Array.prototype.forEach.call(arrayLike, print);
```

上面代码中，`arrayLike`代表一个类似数组的对象，本来是不可以使用数组的`forEach()`方法的，但是通过`call()`，可以把`forEach()`嫁接到`arrayLike`上面调用。

下面的例子就是通过这种方法，在`arguments`对象上面调用`forEach`方法。

```javascript
// forEach 方法
function logArgs() {
  Array.prototype.forEach.call(arguments, function (elem, i) {
    console.log(i + '. ' + elem);
  });
}
// 等同于 for 循环
function logArgs() {
  for (var i = 0; i < arguments.length; i++) {
    console.log(i + '. ' + arguments[i]);
  }
}
```

字符串也是类似数组的对象，所以也可以用`Array.prototype.forEach.call`遍历。

注意，这种方法比直接使用数组原生的`forEach`要慢，所以最好还是先将“类似数组的对象”转为真正的数组，然后再直接调用数组的`forEach`方法。

### 数组的方法

#### 非破坏性方法

##### indexOf()

获取元素在数组中第一次出现的索引

参数：

1.要查询的元素

2.查询的起始位置

##### lastIndexOf()

获取元素在数组中最后一次出现的位置

返回值：

找到了则返回元素的索引，没找到就返回-1

##### join（）

将一个数组中的元素连接为一个字符串

["a","a","a"]->"a,a,a"

参数：指定一个字符串作为连接符

##### slice()

用来截取数组（非破坏性方法）

顾前不顾后

1.截取的起始位置（包括这个位置）

2.截取的结束位置（不包括这个位置）

第二个参数可以省略不写，如果省略则会一直截取到最后，索引可以是负值

如果两个参数全都省略，则可以对数组进行浅拷贝（浅复制）

eg:

```javascript
const arr2=arr.slice
```

若arr2===arr为flase则成功

##### ...展开运算符

将一个数组中的元素展开到另一个数组中或作为函数的参数传递

```javascript
const arr=["aa",...arr,"aaa"]
```

通过这个可以对数组完成一个浅复制 

##### filter()

用来过滤数组中的元素

将数组中符合条件的元素保存到一个新数组中返回 需要一个回调函数作为参数 会为每一个元素去调用回调函数 

并且根据当前的返回值来决定是否添加到新数组中

![image-20230105201400959](C:\Users\飞飞飞飞\AppData\Roaming\Typora\typora-user-images\image-20230105201400959.png)

##### map()

根据当前数组生成一个新数组

![image-20230105201656162](https://tallgao.oss-cn-beijing.aliyuncs.com/image-20230105201656162.png)

需要一个回调函数作为参数，回调函数的返回值会成为新数组中的元素



#### 破坏性方法

##### push()

向数组的末尾添加一个或多个元素,并返回新数组的长度

```javascript
arr.push("b","ll")
```

##### pop()

删除并返回数组最后一个元素

##### unshift()

向数组的开头添加一个或多个元素，并返回新的长度

##### shift()

删除并返回数组的第一个元素

##### splice()

可以删除.添加.插入.替换数组中的元素

参数：

1.删除的起始位置2.删除的数量3.要插入的元素

返回值：返回被删除的元素

**![image-20221230145837134](https://tallgao.oss-cn-beijing.aliyuncs.com/image-20221230145837134.png)

是指删除猪八戒，添加牛魔王，后面是沙和尚和唐僧

插入的话，就是删除的数量为0，然后往里面直接插

##### reverse()

反转数组，顺序直接反过来。

##### sort()

给数组排序 调用后直接排序

用来对数组进行排序（会改变原数组）

默认会将数组升序排列 按照unicode编码排序 所以如果对数字排序可能不正确

传递一个回调函数作为参数 通过回调函数来指定排序规则

![image-20230105195604802](https://tallgao.oss-cn-beijing.aliyuncs.com/image-20230105195604802.png)

forEach()

用来遍历数组  它需要一个回调函数作为参数，这个回调函数会被调用多次  元素中有几个元素，回调函数就会调用几次 每次调用都会将数组中的数据作为参数传递

![image-20230105200342539](https://tallgao.oss-cn-beijing.aliyuncs.com/image-20230105200342539.png)

element当前的元素  index当前元素的索引 array被遍历的数组

reduce(0)

把数组当中的元素整合到一起 第二个值代表的是初始值

![image-20230105202603430](C:\Users\飞飞飞飞\AppData\Roaming\Typora\typora-user-images\image-20230105202603430.png)

## 七.函数

#### 1.概述

![image-20221227093208888](https://tallgao.oss-cn-beijing.aliyuncs.com/image-20221227093208888.png)

##### 1.**function 命令**

`function`命令声明的代码区块，就是一个函数。`function`命令后面是函数名，函数名后面是一对圆括号，里面是传入函数的参数。函数体放在大括号里面。

```javascript
function print(s) {
  console.log(s);
}
```

上面的代码命名了一个`print`函数，以后使用`print()`这种形式，就可以调用相应的代码。这叫做函数的声明（Function Declaration）。

**（2）函数表达式**

除了用`function`命令声明函数，还可以采用变量赋值的写法。

```javascript
var print = function(s) {
  console.log(s);
};
```

这种写法将一个匿名函数赋值给变量。这时，这个匿名函数又称函数表达式（Function Expression），因为赋值语句的等号右侧只能放表达式。

采用函数表达式声明函数时，`function`命令后面不带有函数名。如果加上函数名，该函数名只在函数体内部有效，在函数体外部无效。

```javascript
var print = function x(){
  console.log(typeof x);
};
x
// ReferenceError: x is not defined
print()
// function
```

上面代码在函数表达式中，加入了函数名`x`。这个`x`只在函数体内部可用，指代函数表达式本身，其他地方都不可用。这种写法的用处有两个，一是可以在函数体内部调用自身，二是方便除错（除错工具显示函数调用栈时，将显示函数名，而不再显示这里是一个匿名函数）。因此，下面的形式声明函数也非常常见。

```javascript
var f = function f() {};
```

需要注意的是，函数的表达式需要在语句的结尾加上分号，表示语句结束。而函数的声明在结尾的大括号后面不用加分号。总的来说，这两种声明函数的方式，差别很细微，可以近似认为是等价的。

**（3）Function 构造函数**

第三种声明函数的方式是`Function`构造函数。

```javascript
var add = new Function(
  'x',
  'y',
  'return x + y'
);
// 等同于
function add(x, y) {
  return x + y;
}
```

##### 2.函数的重复声明

如果同一个函数被多次声明，后面的声明就会覆盖前面的声明。

上面代码中，后一次的函数声明覆盖了前面一次。而且，由于函数名的提升（参见下文），前一次声明在任何时候都是无效的，这一点要特别注意。

##### 3.圆括号运算符，return 语句和递归

调用函数时，要使用圆括号运算符。圆括号之中，可以加入函数的参数。

```javascript
function add(x, y) {
  return x + y;
}
add(1, 1) // 2
```

**上面代码中，函数名后面紧跟一对圆括号，就会调用这个函数。**

函数体内部的`return`语句，表示返回。JavaScript 引擎遇到`return`语句，就直接返回`return`后面的那个表达式的值，后面即使还有语句，也不会得到执行。也就是说，`return`语句所带的那个表达式，就是函数的返回值。`return`语句不是必需的，如果没有的话，该函数就不返回任何值，或者说返回`undefined`。

函数可以调用自身，这就是递归（recursion）

##### 第一等公民

JavaScript 语言将函数看作一种值，与其它值（数值、字符串、布尔值等等）地位相同。凡是可以使用值的地方，就能使用函数。比如，可以把函数赋值给变量和对象的属性，也可以当作参数传入其他函数，或者作为函数的结果返回。函数只是一个可以执行的值，此外并无特殊之处。

由于函数与其他数据类型地位平等，所以在 JavaScript 语言中又称函数为第一等公民

##### 函数名的提升

JavaScript 引擎将函数名视同变量名，所以采用`function`命令声明函数时，整个函数会像变量声明一样，被提升到代码头部。所以，下面的代码不会报错。

表面上，上面代码好像在声明之前就调用了函数`f`。但是实际上，由于“变量提升”，函数`f`被提升到了代码头部，也就是在调用之前已经声明了。但是，如果采用赋值语句定义函数，JavaScript 就会报错。

上面代码第二行，调用`f`的时候，`f`只是被声明了，还没有被赋值，等于`undefined`，所以会报错。

注意，如果像下面例子那样，采用`function`命令和`var`赋值语句声明同一个函数，由于存在函数提升，最后会采用`var`赋值语句的定义。

#### 2.函数的属性和方法

##### name 属性

函数的`name`属性返回函数的名字。

```javascript
function f1() {}
f1.name // "f1"
```

如果是通过变量赋值定义的函数，那么`name`属性返回变量名

只有在变量的值是一个匿名函数时才是如此。如果变量的值是一个具名函数，那么`name`属性返回`function`关键字之后的那个函数名。

```javascript
var f3 = function myName() {};
f3.name // 'myName'
```

`name`属性的一个用处，就是获取参数函数的名字。

##### length 属性

函数的`length`属性返回函数预期传入的参数个数，即函数定义之中的参数个数。

它的`length`属性就是定义时的参数个数。

`length`属性提供了一种机制，判断定义时和调用时参数的差异，以便实现面向对象编程的“方法重载”（overload）。

##### toString()

函数的`toString()`方法返回一个字符串，内容是函数的源码。

```javascript
function f() {
  a();
  b();
  c();
}
f.toString()
// function f() {
//  a();
//  b();
//  c();
// }
```

对于那些原生的函数，`toString()`方法返回`function (){[native code]}`

上面代码中，`Math.sqrt()`是 JavaScript 引擎提供的原生函数，`toString()`方法就返回原生代码的提示。

函数内部的注释也可以返回。

利用这一点，可以变相实现多行字符串。

```javascript
var multiline = function (fn) {
  var arr = fn.toString().split('\n');
  return arr.slice(1, arr.length - 1).join('\n');
};
function f() {/*
  这是一个
  多行注释
*/}
multiline(f);
// " 这是一个
//   多行注释"
```

#### 3.函数作用域

##### 定义

作用域（scope）指的是变量存在的范围。在 ES5 的规范中，JavaScript 只有两种作用域：一种是全局作用域，变量在整个程序中一直存在，所有地方都可以读取；另一种是函数作用域，变量只在函数内部存在。ES6 又新增了块级作用域，本教程不涉及。

函数`f`内部可以读取全局变量`v`。

在函数内部定义的变量，外部无法读取，称为“局部变量”（local variable）。

函数内部定义的变量，会在该作用域内覆盖同名全局变量。



函数是一段可以反复调用的代码块。函数还能接受输入的参数，不同的参数会返回不同的值。



作用域（scope）指的是变量存在的范围。在 ES5 的规范中，JavaScript 只有两种作用域：一种是全局作用域，变量在整个程序中一直存在，所有地方都可以读取；另一种是函数作用域，变量只在函数内部存在。ES6 又新增了块级作用域，本教程不涉及。

对于顶层函数来说，函数外部声明的变量就是全局变量（global variable），它可以在函数内部读取。

```
var v = 1;function f() {  console.log(v);}f()// 1
```

上面的代码表明，函数`f`内部可以读取全局变量`v`。

在函数内部定义的变量，外部无法读取，称为“局部变量”（local variable）。

```
function f(){  var v = 1;}v // ReferenceError: v is not defined
```

上面代码中，变量`v`在函数内部定义，所以是一个局部变量，函数之外就无法读取。

函数内部定义的变量，会在该作用域内覆盖同名全局变量。

```
var v = 1;function f(){  var v = 2;  console.log(v);}f() // 2v // 1
```

上面代码中，变量`v`同时在函数的外部和内部有定义。结果，在函数内部定义，局部变量`v`覆盖了全局变量`v`。

注意，对于`var`命令来说，局部变量只能在函数内部声明，在其他区块中声明，一律都是全局变量

##### 函数内部的变量提升

与全局作用域一样，函数作用域内部也会产生“变量提升”现象。`var`命令声明的变量，不管在什么位置，变量声明都会被提升到函数体的头部。

```javascript
function foo(x) {
  if (x > 100) {
    var tmp = x - 100;
  }
}
// 等同于
function foo(x) {
  var tmp;
  if (x > 100) {
    tmp = x - 100;
  };
}
```

##### 函数本身的作用域

函数本身也是一个值，也有自己的作用域。它的作用域与变量一样，就是其声明时所在的作用域，与其运行时所在的作用域无关。

```javascript
var a = 1;
var x = function () {
  console.log(a);
};
function f() {
  var a = 2;
  x();
}
f() // 1
```

上面代码中，函数`x`是在函数`f`的外部声明的，所以它的作用域绑定外层，内部变量`a`不会到函数`f`体内取值，所以输出`1`，而不是`2`。

**总之，函数执行时所在的作用域，是定义时的作用域，而不是调用时所在的作用域。**

```javascript
var x = function () {
  console.log(a);
};
function y(f) {
  var a = 2;
  f();
}
y(x)
// ReferenceError: a is not defined
```

上面代码将函数`x`作为参数，传入函数`y`。但是，函数`x`是在函数`y`体外声明的，作用域绑定外层，因此找不到函数`y`的内部变量`a`，导致报错。

同样的，函数体内部声明的函数，作用域绑定函数体内部。

##### 作用域链

当我们使用同一个变量的时候，

js编辑器优先在当前作用域中寻找变量，如果找到了就直接使用，如果没找到，就去上一层作用域中寻找，找到了就 使用。没找到就继续寻找。

![image-20221227105259058](https://tallgao.oss-cn-beijing.aliyuncs.com/image-20221227105259058.png)

#### 4.箭头函数

![image-20221227093734180](https://tallgao.oss-cn-beijing.aliyuncs.com/image-20221227093734180.png)

![image-20221227153738097](https://tallgao.oss-cn-beijing.aliyuncs.com/image-20221227153738097.png)

##### this

箭头函数没有自己的this,他的this有外层作用域决定，箭头函数this和他的调用方式无关。

当箭头函数只有一个参数的时候，箭头函数的括号可以不写。

使用:

![image-20221227101739690](https://tallgao.oss-cn-beijing.aliyuncs.com/image-20221227101739690.png)

定义参数时，可以为参数指定默认值

```javascript
const fn1 = (s=100,b=200,v=300) => {
	console.log("a=",s);
    console.log("b=",b);
    console.log("c=",v);
}
```

##### 返回值

箭头函数的返回值可以直接写在箭头的后面

**如果直接在箭头后设置对象自变量为返回值时，对象自变量必须用()括起来**

![image-20221227104519969](https://tallgao.oss-cn-beijing.aliyuncs.com/image-20221227104519969.png)

#### 5.方法

函数也可以成为一个对象的属性，在那个函数后面加一个括号()

当一个对象的属性指向一个函数，那么我们就称这个函数是该对象的方法，调用函数就称为调用对象的方法。

#### 6.立即执行函数(IIFE)

一个匿名的函数，并且只会调用函数。

```javascript
// 写法一
var tmp = newData;
processData(tmp);
storeData(tmp);
// 写法二
(function () {
  var tmp = newData;
  processData(tmp);
  storeData(tmp);
}());
```

在开发中应该尽量减少直接在全局作用域中编写代码，所以我们的代码要尽量编写局部作用域。如果使用let声明的变量，可以使用{}来创建块作用域。

#### 7.调用方式



![image-20230105210106396](https://tallgao.oss-cn-beijing.aliyuncs.com/image-20230105210106396.png)

#### 8.参数

##### 参数的省略

函数参数不是必需的，JavaScript 允许省略参数。

但是运行时无论提供多少个参数（或者不提供参数），JavaScript 都不会报错。省略的参数的值就变为`undefined`。需要注意的是，函数的`length`属性与实际传入的参数个数无关，只反映函数预期传入的参数个数。没有办法只省略靠前的参数，而保留靠后的参数。如果一定要省略靠前的参数，只有显式传入`undefined`

```javascript
function f(a, b) {
  return a;
}
f( , 1) // SyntaxError: Unexpected token ,(…)
f(undefined, 1) // undefined
```

##### this

函数在执行的时候，js解析器每次都会传递一个隐含的参数，这个参数就叫this，this会指向一个对象，this所指向的对象会根据函数调用方式的不同而不同。

1.以函数形式调用时，this指向的是window

2.以方法的形式调用时，this指向的是调用方法的对象。

通过this可以在方法中引用调用方法的对象。

##### 传递方式

**传递实参时，传递并不是变量本身，而是变量存储的值。**

**修改对象是，如果其他变量指向这个对象，那么所有指向这个对象的变量都会受到影响。**

函数每次调用，都会重新创建默认值

函数参数如果是原始类型的值（数值、字符串、布尔值），传递方式是**传值传递（passes by value）**。这意味着，在函数体内修改参数值，不会影响到函数外部。

但是，如果函数参数是复合类型的值（数组、对象、其他函数），传递方式是传址传递（pass by reference）。也就是说，传入函数的原始值的地址，因此在函数内部修改参数，将会影响到原始值。

```
obj.p // 2
```

上面代码中，传入函数`f`的是参数对象`obj`的地址。因此，在函数内部修改`obj`的属性`p`，会影响到原始值。

注意，如果函数内部修改的，不是参数对象的某个属性，而是替换掉整个参数，这时不会影响到原始值。

##### 同名参数

如果有同名的参数，则取最后出现的那个值。

##### arguments 对象

**（1）定义**

由于 JavaScript 允许函数有不定数目的参数，所以需要一种机制，可以在函数体内部读取所有参数。这就是`arguments`对象的由来。

`arguments`对象包含了函数运行时的所有参数，`arguments[0]`就是第一个参数，`arguments[1]`就是第二个参数，以此类推。这个对象只有在函数体内部，才可以使用。

正常模式下，`arguments`对象可以在运行时修改。

严格模式下，`arguments`对象与函数参数不具有联动关系。也就是说，修改`arguments`对象不会影响到实际的函数参数。

**（2）与数组的关系**

需要注意的是，虽然`arguments`很像数组，但它是一个对象。数组专有的方法（比如`slice`和`forEach`），不能在`arguments`对象上直接使用。

如果要让`arguments`对象使用数组方法，真正的解决方法是将`arguments`转为真正的数组。下面是两种常用的转换方法：`slice`方法和逐一填入新数组。

```javascript
var args = Array.prototype.slice.call(arguments);
// 或者
var args = [];
for (var i = 0; i < arguments.length; i++) {
  args.push(arguments[i]);
}
```

**（3）callee 属性**

`arguments`对象带有一个`callee`属性，返回它所对应的原函数。

可以通过`arguments.callee`，达到调用函数自身的目的。这个属性在严格模式里面是禁用的，因此不建议使用。

##### 闭包

闭包（closure）是 JavaScript 语言的一个难点，也是它的特色，很多高级应用都要依靠闭包实现。

理解闭包，首先必须理解变量作用域。前面提到，JavaScript 有两种作用域：全局作用域和函数作用域。函数内部可以直接读取全局变量。

函数外部无法读取函数内部声明的变量。

得到函数内的局部变量：**正常情况下，这是办不到的，只有通过变通方法才能实现。那就是在函数的内部，再定义一个函数。**

```javascript
function f1() {
  var n = 999;
  function f2() {
　　console.log(n); // 999
  }
}
```

上面代码中，函数`f2`就在函数`f1`内部，这时`f1`内部的所有局部变量，对`f2`都是可见的。但是反过来就不行，`f2`内部的局部变量，对`f1`就是不可见的。这就是 JavaScript 语言特有的”链式作用域”结构（chain scope），子对象会一级一级地向上寻找所有父对象的变量。所以，父对象的所有变量，对子对象都是可见的，反之则不成立。

既然`f2`可以读取`f1`的局部变量，那么只要把`f2`作为返回值，我们不就可以在`f1`外部读取它的内部变量了吗！

```javascript
function f1() {
  var n = 999;
  function f2() {
    console.log(n);
  }
  return f2;
}
var result = f1();
result(); // 999
```

上面代码中，函数`f1`的返回值就是函数`f2`，由于`f2`可以读取`f1`的内部变量，所以就可以在外部获得`f1`的内部变量了。

闭包就是函数`f2`，即能够读取其他函数内部变量的函数。由于在 JavaScript 语言中，只有函数内部的子函数才能读取内部变量，因此可以把闭包简单理解成“定义在一个函数内部的函数”。闭包最大的特点，就是它可以“记住”诞生的环境，比如`f2`记住了它诞生的环境`f1`，所以从`f2`可以得到`f1`的内部变量。在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。

闭包的最大用处有两个，**一个是可以读取函数内部的变量**，**另一个就是让这些变量始终保持在内存中**，即闭包可以使得它诞生环境一直存在。请看下面的例子，闭包使得内部变量记住上一次调用时的运算结果。

```javascript
function createIncrementor(start) {
  return function () {
    return start++;
  };
}
var inc = createIncrementor(5);
inc() // 5
inc() // 6
inc() // 7
```

上面代码中，`start`是函数`createIncrementor`的内部变量。通过闭包，`start`的状态被保留了，每一次调用都是在上一次调用的基础上进行计算。从中可以看到，闭包`inc`使得函数`createIncrementor`的内部环境，一直存在。所以，闭包可以看作是函数内部作用域的一个接口。

为什么会这样呢？原因就在于`inc`始终在内存中，而`inc`的存在依赖于`createIncrementor`，因此也始终在内存中，不会在调用结束后，被垃圾回收机制回收。

**闭包的另一个用处，是封装对象的私有属性和私有方法。**

外层函数每次运行，都会生成一个新的闭包，而这个闭包又会保留外层函数的内部变量，所以内存消耗很大。因此不能滥用闭包，否则会造成网页的性能问题。

##### 立即调用的函数表达式（IIFE）

在 JavaScript 中，圆括号`()`是一种运算符，跟在函数名之后，表示调用该函数。比如，`print()`就表示调用`print`函数。

有时，我们需要在定义函数之后，立即调用该函数。这时，你不能在函数的定义之后加上圆括号，这会产生语法错误。

产生这个错误的原因是，`function`这个关键字即可以当作语句，也可以当作表达式。

JavaScript 引擎规定，如果`function`关键字出现在行首，一律解释成语句。因此，JavaScript 引擎看到行首是`function`关键字之后，认为这一段都是函数的定义，不应该以圆括号结尾，所以就报错了。

解决方法就是不要让`function`出现在行首，让引擎将其理解成一个表达式。最简单的处理，就是将其放在一个圆括号里面。

引擎就会认为后面跟的是一个表示式，而不是函数定义语句，所以就避免了错误。这就叫做“立即调用的函数表达式”（Immediately-Invoked Function Expression），简称 IIFE。

任何让解释器以表达式来处理函数定义的方法，都能产生同样的效果，比如下面三种写法。

```javascript
var i = function(){ return 10; }();
true && function(){ /* code */ }();
0, function(){ /* code */ }();
```

通常情况下，只对匿名函数使用这种“立即执行的函数表达式”。它的目的有两个：一是不必为函数命名，避免了污染全局变量；二是 IIFE 内部形成了一个单独的作用域，可以封装一些外部无法读取的私有变量。

```javascript
// 写法一
var tmp = newData;
processData(tmp);
storeData(tmp);
// 写法二
(function () {
  var tmp = newData;
  processData(tmp);
  storeData(tmp);
}());
```

上面代码中，写法二比写法一更好，因为完全避免了污染全局变量。

##### eval 命令

###### 基本用法

`eval`命令接受一个字符串作为参数，并将这个字符串当作语句执行。

```javascript
eval('var a = 1;');
a // 1
```

如果参数字符串无法当作语句运行，那么就会报错。

放在`eval`中的字符串，应该有独自存在的意义，不能用来与`eval`以外的命令配合使用。

`return`不能单独使用，必须在函数中使用。

如果`eval`的参数不是字符串，那么会原样返回。

`eval`没有自己的作用域，都在当前作用域内执行，因此可能会修改当前作用域的变量的值，造成安全问题。

为了防止这种风险，JavaScript 规定，如果使用严格模式，`eval`内部声明的变量，不会影响到外部作用域。

不过，即使在严格模式下，`eval`依然可以读写当前作用域的变量。

```javascript
(function f() {
  'use strict';
  var foo = 1;
  eval('foo = 2');
  console.log(foo);  // 2
})()(function f() {
```

总之，`eval`的本质是在当前作用域之中，注入代码。由于安全风险和不利于 JavaScript 引擎优化执行速度，所以一般不推荐使用。通常情况下，`eval`最常见的场合是解析 JSON 数据的字符串，不过正确的做法应该是使用原生的`JSON.parse`方法。

###### eval 的别名调用

前面说过`eval`不利于引擎优化执行速度。更麻烦的是，还有下面这种情况，引擎在静态代码分析的阶段，根本无法分辨执行的是`eval`。

上面代码中，变量`m`是`eval`的别名。静态代码分析阶段，引擎分辨不出`m('var x = 1')`执行的是`eval`命令。

为了保证`eval`的别名不影响代码优化，JavaScript 的标准规定，凡是使用别名执行`eval`，`eval`内部一律是全局作用域。

`eval`的别名调用的形式五花八门，只要不是直接调用，都属于别名调用，因为引擎只能分辨`eval()`这一种形式是直接调用。

##### 可变参数

arguments时函数的又一个隐含参数  是一个类数组（伪数组）对象 是一个用来存储函数的实参  无论用户是否定义形参，实参都会存储到arguments对象中，可以通过这个对象直接访问实参  可以通过索引来读取元素，也可以通过/for循环变量，但他不是一个数组对象，不能调用数组方法

![image-20230105203954703](https://tallgao.oss-cn-beijing.aliyuncs.com/image-20230105203954703.png)

可变参数：在定义函数时可以将参数指定为可变参数 可变参数可以接受任意数量实参，并将它们统一存储到一个数组中返回

![image-20230105205119887](https://tallgao.oss-cn-beijing.aliyuncs.com/image-20230105205119887.png)

