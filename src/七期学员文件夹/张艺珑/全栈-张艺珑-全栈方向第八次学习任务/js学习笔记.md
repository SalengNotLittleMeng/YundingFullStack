# js学习笔记（一）

## 输出语句

* 输出语句

  - console.log()

  在控制台打印东西

  - alert()

  弹出警示框

  - confirm()

  弹出带有确定和取消按钮的对话框，确定返回true，取消返回false。

* 输入语句

  - prompt()

  弹出输入框，用户可以输入

## 变量声明

- var var声明的变量没有块作用域，有函数作用域
- let let声明的变量有块作用域

- 变量未正确使用的三种情况
  - 声明未赋值 显示undefined
  - 未声明已赋值 可以打印值，但不建议使用
  - 未声明未赋值 报错

## 基本数据类型

- number
  - 整数、浮点数
  - NaN(not a number)
- string
  - 各种字符包括空字符
- boolean
  - true false

- undefined 声明未赋值

- null 声明未空对象

- symbol

  - 创建一个唯一标识，调用Symbol()函数


- bigint 数字后面跟上一个n,代表大整数

## 类型转换

- 转换为字符串

  - tostring()方法 无参数
  - String()函数 有参数
  - 拼接字符串 有字符串和+就是字符串

  ```javascript
  let num = 123;
  console.log(num.toString());
  console.log(String(num));
  ```

- 转换未数字型

  - parseInt()

  字符在前会返回NaN，数字在前会去点字符，会把小数点截断，不会四舍五入，true返回1，false返回0，空串返回0。

  - parseFloat()

  parseFloat()和parseFioat()一样，只是不会截断小数点。

  - Number()

  不合法的会返回NaN，空串会返回0

  - 有隐式转换 有* / -

  ```javascript
  let str = '12345'
  console.log(parseInt(str),parse(str))

**注：**数据转换并不会改变类型二十根据数据类型创建一个新的值。

## 运算符

- ===	类型数值都相等

- !==     类型不同，数值相同

- **      次方运算

- 逻辑中断（当逻辑运算符两边不是布尔值而是表达式或者值时，就会有逻辑中断）

  - 逻辑与

  表达式1&&表达式2

  如果第一个表达式为真则返回表达式2，如果第一个表达式为假则返回表达式1。

  - 逻辑或

  表达式1||表达式2

  如果第一个表达式为真返回表达式1，第一个表达式为假返回表达式2。

**<font color="red">注</font>**：浮点数进行算术运算会有精度问题，不要拿浮点数比较是否相等。

## 数组

- 创建数组的方法

  - 用new关键字 `let array = new Array()`,<font color="red">A必须大写</font>

  - 用数组字面量  `let array = [1,'sting',123n]`,数据用逗号分隔，可以放任意的数据类型。

    **注**：在创建数组时尽量确保数组中存储的数据类型是相同的。

- 数组长度

数组名.length 可以动态监测数组长度，可以修改数组名.length来修改数组长度或者追加数组元素，不用扩容。千万不要给数组名赋值，会覆盖之前的值。

- 内置对象方法（[参考文档MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array)）

  - 静态方法

    - `Array.isArray()` 参数是数组返回true,否则返回false。

  - 实例方法

    - `实例名.at()`  要返回的数组元素的索引（位置）。当传递负数时，支持从数组末端开始的相对索引；也就是说，如果使用负数，返回的元素将从数组的末端开始倒数。
    - `实例名.concat() 非破坏性方法` 合并两个或者多个数组。参数：数组/值，如果省略参数，则会返回调用此方法的现存数组的一个浅拷贝。
    - `实例名.filter() 非破坏性方法` 将数组中符合条件的元素保存到一个新的数组中返回。需要一个回调函数作为参数 ，回调函数有三个参数：element，index，array。`filter()` 为数组中的每个元素调用一次 `callbackFn` 函数，并利用所有使得 `callbackFn` 返回 true 或等价于 true 的值的元素创建一个新数组。
    - `实例名.forEach() 破坏性方法` 遍历数组，需要一个回调函数作为参数，有几个元素，就会调用几次。每次调用，及那个数组中的数据作为参数传递。没找到返回-1.
    - `实例名.indexOf() 非破坏性方法` 获取元素在数组中第一次出现的索引 ，参数：要查询的元素，起始位置。
    - `实例名.lastIndexOf() 非破坏行方法`  获取元素在数组中最后一次出现的索引 ，没找到返回-1。
    - `实例名.join() 非破坏性方法` 将元素连接成字符串，字符串中的元素用逗号隔开。
    - `实例名.slice() 非破坏性方法` 截取数组，参数：起始位置（包括该位置），结束位置（不包括该位置）。第二个参数可以省略不写，表示从起始位置到数组结束。参数可以是负数，代表从后往前数。参数都省略代表浅拷贝。

    - `实例名.push() 破坏性方法` 在数组末尾添加一个或多个元素，返回新数组长度。
    - `实例名.unshift() 破坏性方法` 在数组开头添加一个或多个元素，返回新数组长度。
    - `实例名.pop() 破坏性方法` 删除数组的最后一个元素，返回删除的元素。
    - `实例名.shift() 破坏性方法` 删除数组的第一个元素，返回删除的元素。
    - `实例名.reverse() 破坏性方法` 翻转数组
    - `实例名.sort() 破坏性方法` 对数组排序<font color="red">默认将数组升序排序，按照Unicode编码排序</font>，参数：传一个回调函数作为参数，指定排序规则。(a,b) =>a-b 升序 (a,b) => b-a 降序
    - `实例名，splice() 破坏性方法` 删除或替换现有元素，参数：起始位置，删除数量，插入元素。

## 对象

- 创建方法

  - 字面量

  ```js
  let obj ={
      name: '',
      age:  ,
      sayHello: function() {
          console.log('hello')
      }
  };
  // 属性方法用键值对形式存入，多个属性用逗号隔开，方法冒号后面跟匿名函数
  ```

  - new Object()

  ```js
  let obj = new Object(); // 追加属性
  obj.name = '';
  obj.age =  ;
  obj.sayHello = function() {
      
  };
  // 等号赋值，分号结尾
  ```

  - 类

  ```js
  class Person {
      name = ''; // 实例属性，只能通过实例调用
      sayHi = function(){
          
      }; // 实例方法，只能通过实例调用
      static name = ''; // 静态属性，只能通过类调用
      static sayHi = function () {
          
      } // 静态方法，只能通过类调用
      // 在类中添加一个特殊的方法，constructor
      constructor(name,age) {
          this.name = name;
          this.age= age;
      }
      // 构造函数在调用类创建对象时执行，在构造函数中，为实例属性赋值，构造函数中，this表示当前创建的对象。
  }
  ```

- 面向对象三大特性

  - 封装（安全性）

  1.用来存储不同属性的容器

  2.负责属性的安全

  3.直接添加到对象中的属性不安全，为了确保数据的安全，我们私有化数据，#属性名，只能在类内部访问

  4.用get,set方法来获取数据的权限，控制属性的读写权限，可以在方法中添加验证来确保格式正确

  - 继承（可拓展性）

  可以通过extends关键字来完成继承，被继承的类称为父类（超类），继承的类称为子类，继承可以减少重复的代码，子类中，可以创建同名方法来重些父类的方法。重写构造函数时，第一行代码就应该时super()。方法中可以用super()来引用父类的方法。<font color='red'>通过继承可以在不修改一个类的情况下对其进行扩展，OCP原则，程序应该对修改关闭，对扩展开放</font>

  - 多态（灵活性）

  js不会检查参数的类型，要调用某个函数只要对象满足某些条件即可。

- 原型（实例的隐式原型指向类的显式原型）

  - 对象存储区域有两个：1.对象自身，直接添加在类中，xxx = xxx形式

  ​                                               2.原型对象，对象在会有一个属性，叫\__proto\__指向原型对   象，在访问对象属性或者方法时，先在对象自身赵，找不到去原型中找。

  - 原型对象中的数据：1.对象中的数据

  ​                                          2.constructor

  - 作用：1.所有的同类型对象他们的原型对象都是同一个，同类型对象的原型链一样，原型是个公共区域，可以被所有的该类实例访问，减少内存资源的浪费。

## 函数

函数（Function）
                - 函数也是一个对象
                                - 它具有其他对象所有的功能
                   - 函数中可以存储代码，且可以在需要时调用这些代码
                
                   - 语法：
                                     function 函数名(){
                                         语句...
                                     }
                
                   - 调用函数：
                                     - 调用函数就是执行函数中存储的代码
                                                     - 语法：
                                         函数对象()
                
                     使用typeof检查函数对象时会返回function

<hr>

- 定义方式

函数的定义方式：
                1.函数声明
                    function 函数名(){
                        语句...
                    }

​                2.函数表达式

​               	const 变量 = function(){

​					  语句...

​					}

​                3.箭头函数

​                         （） => {

​								语句...

​							}

<hr>

- 参数

```js
/* 
            定义一个可以求任意两个数和的函数
        */

        // function sum(){
        //     let a = 123
        //     let b = 456
        //     console.log(a + b)
        // }

        // const sum2 = () => console.log(1 + 1)
        // sum()

        /* 
            形式参数
                - 在定义函数时，可以在函数中指定数量不等的形式参数（形参）
                - 在函数中定义形参，就相当于在函数内部声明了对应的变量但是没有赋值

            实际参数
                - 在调用函数时，可以在函数的()传递数量不等的实参
                - 实参会赋值给其对应的形参
                - 参数：
                    1.如果实参和形参数量相同，则对应的实参赋值给对应的形参
                    2.如果实参多余形参，则多余的实参不会使用
                    3.如果形参多余实参，则多余的形参为undefined

                - 参数的类型
                    - JS中不会检查参数的类型，可以传递任何类型的值作为参数

            1.函数声明
                    function 函数名([参数]){
                        语句...
                    }

            2.函数表达式
                const 变量 = function([参数]){
                    语句...
                }

            3.箭头函数
                ([参数]) => {
                    语句...
                }
        */
```

```js
const fn = (a, b) => {
            console.log("a =", a);
            console.log("b =", b);
        }


        // 当箭头函数中只有一个参数时，可以省略()
        const fn2 = a => {
            console.log("a =", a);
        }


        // fn2(123)

        // 定义参数时，可以为参数指定默认值
        // 默认值，会在没有对应实参时生效
        const fn3 = (a=10, b=20, c=30) => {
            console.log("a =", a);
            console.log("b =", b);
            console.log("c =", c);
        }
```

<hr>

- 返回值

在函数中，可以通过return关键字来指定函数的返回值
                    返回值就是函数的执行结果，函数调用完毕返回值便会作为结果返    任何值都可以作为返回值使用（包括对象和函数之类）
                如果return后不跟任何值，则相当于返回undefined
                如果不写return，那么函数的返回值依然是undefined

​            return一执行函数立即结束

<hr>

- 作用域

作用域（scope）
                - 作用域指的是一个变量的可见区域
                                - 作用域有两种：
                    全局作用域
                        - 全局作用域在网页运行时创建，在网页关闭时消耗
                            - 所有直接编写到script标签中的代码都位于全局作用域中
                            - 全局作用域中的变量是全局变量，可以在任意位置访问
                    
                    局部作用域
                       - 块作用域
                            - 块作用域是一种局部作用域
                            - 块作用域在代码块执行时创建，代码块执行完毕它就销毁
                            - 在块作用域中声明的变量是局部变量，只能在块内部访问，外部无法访问

作用域链
                - 当我们使用一个变量时，
                    JS解释器会优先在当前作用域中寻找变量，
                        如果找到了则直接使用
                        如果没找到，则去上一层作用域中寻找，找到了则使用
                        如果没找到，则继续去上一层寻找，以此类推
                        如果一直到全局作用域都没找到，则报错 xxx is not defined

<hr>

- 预解析

使用var声明的变量，会在所有代码执行前被声明，所以我们可以在变量声明前就访问变量。使用函数声明创建的函数也会在所有代码执行前声明

- 立即执行函数

在开发中应该尽量减少直接在全局作用域中编写代码！

 所以我们的代码要尽量编写的局部作用域

 如果使用let声明的变量，可以使用{}来创建块作用域

立即执行函数是一个匿名的函数，并且他只会调用一次，可以用IIFE来创建一个一次性函数作用域，避免变量冲突问题。

`(function{})();`

- 严格模式

JS运行代码的模式有两种：
                - 正常模式
                    - 默认情况下代码都运行在正常模式中，
                        在正常模式，语法检查并不严格
                        它的原则是：能不报错的地方尽量不报错
                        
                    - 这种处理方式导致代码的运行性能较差           
                    
                    -   严格模式
                    
                                        - 在严格模式下，语法检查变得严格
                    
                                            1.禁止一些语法
                    
                                            2.更容易报错
                    
                                            3.提升了性能
                    
                    
                                    - 在开发中，应该尽量使用严格模式，
                    
                                        这样可以将一些隐藏的问题消灭在萌芽阶段，
                    
                                        ​    同时也能提升代码的运行性能

`use strict` //  使用严格模式