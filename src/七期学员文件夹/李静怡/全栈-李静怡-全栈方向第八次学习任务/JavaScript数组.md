# JS数组

## 定义

数组（array）是按次序排列的一组值。每个值的位置都有编号（从0开始），整个数组用方括号表示。

赋值：

- 在定义时赋值
- 先定义后赋值

值的类型：

- 任何类型的数据，都可以放入数组。
- 如果数组的元素还是数组，就形成了多维数组。






## 与C语言的区别

### 格式

- C语言：方括号中是数组长度
- JavaScript：方括号中是元素

### 本质

- C：可从指针理解
- JS：对象

### 添加

- C：静态，可能溢出
- JS：动态的数据结构，可以随时增减数组的成员

### 方法

- C：较少，较易掌握。由于方法较少，可能需要较大量的代码才能实现某个功能
- JS：较多，较难掌握。由于方法较多，可能有简单的方法就能够实现较为复杂的功能（如排序可以直接用sort解决），但掌握、挑选和积累的过程需要下功夫

### 应用

- C：跨范围程度不算很大，常见拓展是字符数组和结构体数组
- JS：由于有伪数组的存在以及数组中可存储任意类型的值，数组的应用相当之广（如在DOM中，通过类名获取的元素就是以伪数组形式保存的）





## 数组的基本知识

### 数组的本质

本质上，数组属于一种特殊的对象。`typeof`运算符会返回数组的类型是`object`。

### 键名

数组的特殊性体现在，它的**键名是按次序排列的一组整数（0，1，2…）**。

由于数组成员的键名是固定的（默认总是0、1、2…），因此数组不用为每个元素指定键名，而对象的每个成员都必须指定键名。

JavaScript 语言规定，对象的键名一律为字符串，所以，数组的键名其实也是**字符串**。之所以可以用数值读取，是因为非字符串的键名会被转为字符串。

### 读取

- 对象的键名：点结构（`object.key`）和方括号结构（`object[key]`）

- 数值的键名：不能使用点结构。

  因为单独的数值不能作为标识符（identifier）。所以，**数组成员只能用方括号`arr[0]`表示**（方括号是运算符，可以接受数值）。




## length 属性

数组的`length`属性，返回数组的成员数量。

JavaScript 使用一个32位整数，保存数组的元素个数。这意味着，数组成员最多只有 4294967295 个（2^32 - 1）个，也就是说`length`属性的最大值就是 4294967295。

### 规则

只要是数组，就一定有`length`属性。该属性是一个动态的值，等于键名中的最大整数加上`1`。

数组的数字键不需要连续，`length`属性的值总是比最大的那个整数键大`1`。另外，这也表明数组是一种**动态**的数据结构，可以随时增减数组的成员

值得注意的是，由于数组本质上是一种对象，所以可以为数组添加属性，但是这不影响`length`属性的值。

因为，`length`属性的值就是等于最大的数字键加1，而这个数组没有整数键，所以`length`属性保持为`0`。

如果数组的键名是添加超出范围的数值，该键名会自动转为字符串。

**`length`属性不过滤空位**。所以，使用`length`属性进行数组遍历，一定要非常小心。

### 设置length

`length`属性是可写的。

- 如果人为设置一个小于当前成员个数的值，该数组的成员数量会自动减少到`length`设置的值。
- 将`length`属性设为0，清空数组
- 如果人为设置`length`大于当前元素个数，则数组的成员数量会增加到这个值，新增的位置都是空位。当`length`属性设为大于数组个数时，读取新增的位置都会返回`undefined`。

- 如果人为设置`length`为不合法的值，JavaScript 会报错。






## in 运算符

检查某个**键名**是否存在的运算符`in`，适用于对象，也适用于数组。

注意，如果数组的某个位置是空位，`in`运算符返回`false`。

```javascript
var arr = [];
arr[100] = 'a';

100 in arr // true
1 in arr // false
```

上面代码中，数组`arr`只有一个成员`arr[100]`，其他位置的键名都会返回`false`。





## 数组的遍历

### for循环或while循环

数组的遍历可以考虑使用`for`循环或`while`循环。

```javascript
var a = [1, 2, 3];

// for循环
for(var i = 0; i < a.length; i++) { 
    console.log(a[i]);
}

// while循环
var i = 0;
while (i < a.length) { 
    console.log(a[i]); 
    i++;
}

var l = a.length;
while (l--) { 
    console.log(a[l]);
}
```

上面代码是三种遍历数组的写法。最后一种写法是逆向遍历，即从最后一个元素向第一个元素遍历。

### for…in 循环

`for...in`循环不仅可以遍历对象，也可以遍历数组，毕竟数组只是一种特殊对象。

for(let i in obj){

}

i：得到的是属性名

obj[i]：得到的是属性值

```javascript
var a = [1, 2, 3];

for (var i in a) {
    console.log(a[i]);
}
// 1
// 2
// 3
```

但是，`for...in`不仅会遍历数组所有的数字键，还会遍历非数字键。

```javascript
var a = [1, 2, 3];
a.foo = true;

for (var key in a) { 
    console.log(key);
}
// 0
// 1
// 2
// foo
```

上面代码在遍历数组时，也遍历到了非整数键`foo`。所以，不推荐使用`for...in`遍历数组。

### for...of 循环

- for...in：对象和数组都可遍历
- for...of：遍历可迭代对象

```javascript
for(变量 of 可迭代对象) {
    ...
}
```

每执行一次都会将一个元素赋给变量，因此可以直接通过该变量来访问元素

仅可从前往后遍历

### forEach 方法

数组的`forEach`方法，也可以用来遍历数组，详见《标准库》的 Array 对象一章。

```javascript
var colors = ['red', 'green', 'blue'];
colors.forEach(function (color) {  
    console.log(color);
});
// red
// green
// blue
```





## 数组的空位

当数组的某个位置是空元素，即两个逗号之间没有任何值，我们称该数组存在空位（hole）。

上面代码表明，数组的空位不影响`length`属性。

需要注意的是，如果**最后一个元素后面**有逗号，并不会产生空位。也就是说，有没有这个逗号，结果都是一样的。数组最后一个成员后面有一个逗号，这不影响`length`属性的值，与没有这个逗号时效果一样。

数组的空位是可以读取的，返回`undefined`。

使用`delete`命令删除一个数组成员，会形成空位，并且不会影响`length`属性。

数组的某个位置是空位，与某个位置是`undefined`，是不一样的。

- 如果是空位，使用数组的`forEach`方法、`for...in`结构、以及`Object.keys`方法进行遍历，空位都会被跳过。

  空位就是数组没有这个元素，所以不会被遍历到

- 如果某个位置是`undefined`，遍历的时候就不会被跳过。

  `undefined`则表示数组有这个元素，值是`undefined`，所以遍历不会跳过





## 数组的方法

通过该链接查找：https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array

### Array.isArray()

用来检查一个对象是否是数组

### at()

可以根据索引获取数组中的指定元素

at可以接收负索引作为参数

### concat()

用来连接两个或多个数组

非破坏性方法，不会影响原数组，而是返回一个新的数组

### indexof()

获取元素在数组中第一次出现的索引

参数:

1. 要查询的元素
2. 查询的起始位置

### lastIndexOf()

获取元素在数组中最后一次出现的位置

返回值:

- 找到了则返回元素的索引，

- 没有找到返回-1


### join()

将一个数组中的元素连接为一个字符串

["孙悟空"，"猪八戒"，“沙和尚”，"唐僧"，“沙和尚"]->"孙悟空，猪八戒，沙和尚，唐僧，沙和尚”

参数:

​	指定一个字符串作为连接符

### slice()

-用来截取数组（非破坏性方法）

参数:

1. 截取的起始位置（包括该位置）

2. 截取的结束位置（不包括该位置）

​		第二个参数可以省略不写，如果省略则会一直截取到最后

索引可以是负值

如果将两个参数全都省略，则可以对数组进行浅拷贝(浅复制)

### sort()

sort用来对数组进行排序（会对改变原数组）

sort默认会将数组升序排列

sort可以对任意值进行排序，其过程是将值转化为字符串，然后按照Unicode编码进行排序

注意：因此如果直接通过sort对数字进行排序，可能会得到一个不正确的结果

参数:

可以传递一个回调函数作为参数，通过回调函数来指定排序规则

在对纯数字数组排序时，使用如下参数：

- (a,b)=> a - b 升序排列

- (a,b)=>b- a 降序排列


### forEach()

用来遍历数组

它需要一个回调函数作为参数，这个回调函数会被调用多次，数组中有几个元素，回调函数就会调用几次

每次调用，都会将数组中的数据作为参数传递

回调函数中有三个参数:

- element 当前的元素
- index 当前元素的索引
- array 被遍历的数组（不是数组名）

### filter(）

将数组中符合条件的元素保存到一个新数组中返回

需要一个回调函数作为参数，会为每一个元素去调用回调函数，并根据返回值来决定是否将元素添加到新数组中

回调函数中有三个参数:

- element 当前的元素
- index 当前元素的索引
- array 被遍历的数组（不是数组名）

非破坏性方法，不会影响原数组

### map()

根据当前数组生成一个新数组

需要一个回调函数作为参数，回调函数的返回值会成为新数组中的元素。eg：

```javascript
//将数组中的字符串分别变成标签插入html中
arr = ['孙悟空','猪八戒','沙僧']
let result = arr.map(ele => <li> + ele + </li>)
```

回调函数中有三个参数:

- element 当前的元素
- index 当前元素的索引
- array 被遍历的数组（不是数组名）

非破坏性方法，不会影响原数组

### reduce()

可以用来将一个数组中的所有元素整合为一个值

参数:

1. 回调函数，通过回调函数来指定合并的规则

2. 可选参数，初始值





## 类似数组的对象

如果一个对象：

- 所有键名都是正整数或零
- 并且有`length`属性（**这种**`length`属性不是动态值，不会随着成员的变化而变化。）

那么这个对象就很像数组，语法上称为“类似数组的对象”（array-like object）。

```javascript
var obj = { 
    0: 'a',
    1: 'b', 
    2: 'c', 
    length: 3
};

obj[0] // 'a'
obj[1] // 'b'
obj.length // 3
obj.push('d') // TypeError: obj.push is not a function
```

但是，“类似数组的对象”并不是数组，因为它们不具备数组特有的方法。对象`obj`没有数组的`push`方法，使用该方法就会报错。

上面代码为对象`obj`添加了一个数字键，但是`length`属性没变。这就说明了`obj`不是数组。

典型的“类似数组的对象”是函数的`arguments`对象，以及大多数 DOM 元素集，还有字符串。

数组的`slice`方法可以将“类似数组的对象”变成真正的数组。

```javascript
var arr = Array.prototype.slice.call(arrayLike);
```

除了转为真正的数组，“类似数组的对象”还有一个办法可以使用数组的方法，就是通过`call()`把数组的方法放到对象上面。

```javascript
function print(value, index) { 
    console.log(index + ' : ' + value);
}

Array.prototype.forEach.call(arrayLike, print);
```

上面代码中，`arrayLike`代表一个类似数组的对象，本来是不可以使用数组的`forEach()`方法的，但是通过`call()`，可以把`forEach()`嫁接到`arrayLike`上面调用。

下面的例子就是通过这种方法，在`arguments`对象上面调用`forEach`方法。

```javascript
// forEach 方法
function logArgs() { 
    Array.prototype.forEach.call(arguments, function (elem, i) {  
        console.log(i + '. ' + elem);  
    });
}

// 等同于 for 循环
function logArgs() { 
    for (var i = 0; i < arguments.length; i++) {  
        console.log(i + '. ' + arguments[i]); 
    }
}
```

字符串也是类似数组的对象，所以也可以用`Array.prototype.forEach.call`遍历。

```javascript
Array.prototype.forEach.call('abc', function (chr) { 
    console.log(chr);
});
// a
// b
// c
```

注意，这种方法比直接使用数组原生的`forEach`要慢，所以最好还是先将“类似数组的对象”转为真正的数组，然后再直接调用数组的`forEach`方法。

```javascript
var arr = Array.prototype.slice.call('abc');
arr.forEach(function (chr) {
    console.log(chr);
});
// a
// b
// c
```

