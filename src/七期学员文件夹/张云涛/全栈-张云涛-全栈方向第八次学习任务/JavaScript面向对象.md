# JavaScript面向对象

### 1.类

1).类是对象的模板，可以将对象中的属性和方法定义在类中，通过类来创建对象

2).通过同一个类创建的对象，成为同类对象，这个对象被称为该类的实例；可以通过instanceof检查某对象是否有某个类创建

3).创建类   `class Person { name,age,static gender，run(){},sleep = founction(){}};` `const Person = class {};`

使用static声明的属性为静态属性，也叫类属性，只能通过类去访问；其他声明的属性为实例属性，只能通过实例去访问。方法也是如此

4).构造函数

> 实现在创建对象时为其属性赋值

`constructor(){}`该函数在创建对象时被调用；构造函数当中的this指向当前所创建的对象

```
class Person{
	name,
	age,
	gender,
	constructor(name,age,gender){
		this.name = name;
		this.age = age;
		this.gender = gender;
	}
}
const p1 = new Person('',18,'男');
```

**注意:**类的方法之间不要放置逗号，这会导致语法错误

### 2.封装

> 对象不仅用来存储不同数据，同时还要保证数据的安全

- 直接添加到对象当中的属性并不安全，他们可以被随意的修改
- 为保证数据的安全，需要将对象封装

封装的实现方式

- 属性私有化

  - 在属性前加#     私有化的属性只能在对象内部被访问，外部无法访问

- 通过getter方法和setter方法来设置属性

  - ```
    get 属性名() {
    	return this.#属性
    }	           这样在外部就可以直接读到属性值
    ```

  - 

    ```
    set 属性名(参数) {
    	this.#属性 = 参数
    }	           这样在外部就可以直接修改属性值
    ```

### 3.多态

> 多态提供了灵活性

传入函数的参数不做类型检查 

### 4.继承

> OCP原则   程序应该第修改关闭，对扩展开放

子类可以继承父类(超类)的代码，且可以在不修改父类的前提下对其进行扩展

```
class Dog extends Animal {}
```

- 当我们想要修改父类当中的方法时，只需要在子类下创建同名方法即可；但在重写构造函数时，第一行需加上super();

- 当我们在修改父类的方法时，我们仍想在新方法中去调用父类的方法，可以super.方法名

### 5.对象的结构

对象存储属性的区域有两个：

- 对象自身
  - 直接通过对象创建的属性直接存储与对象当中
  - 通过 x = y创建的属性存储与对象自身当中

- 原型对象(prototype) 
  - 通过 (){}方式添加的方法，存储在原型对象当中
  - 主动向原型中添加的属性或方法
  - 当我们访问对象当中的属性时，会优先访问对象自身的属性，没有的话才会访问原型对象
  - 对象中用_ _ proto _ _ 属性来存储原型对象

### 6.原型的数据

1).访问原型对象的途径

- 对象._ _proto _ _
- Object.getPrototypeof(对象)

2).原型对象中的数据

- 对象的数据
- constructor(对象的构造函数)

3).原型对象当中也有原型对象，这就构成了一条原型链，其长度取决于对象的复杂程度，原型链的末端为null

4).原型链用于寻找对象的属性，找不到返回undefined；作用域链用于寻找变量，找不到会报错

5).原型的作用

- 所用同类对象的原型是一样的，该类的实例的原型链都是相同的
- 原型中的属性可以被同类的对象访问，对于相同的属性放在原型中，实际上是节省了内存
- JS的继承就是通过原型来实现的

6).原型的修改

- 一般不要对原型进行修改
- 修改的时候可以通过类.prototype属性来修改，可以在原型当中添加属性或方法，但最好不要给原型进行赋值

7).

- instanceof用于检查对象是否是类的实例
- in用于检查属性是否为对象的属性
- hasOwnProperty(属性名)用于检查属性是否存储于对象中，如果存储于对象中会返回true，否则则返回false
- Obeject.hasOwn(对象，‘属性名’)是hasOwnProperty()的替代方法

8).旧类通过函数来创建

```
var 类名1 (function 类名1(){
	
}
类名1.prototype = 类名2				//原型继承
return 类名
)()
```

### 7.new运算符

当用new调用函数时，会发生一下流程

- 在函数当中新建一个对象
- 将构造函数的prototype属性设置为新对象的原型
- 传入实参时，构造函数的this指向新对象
- 当返回值是原始值或没有指定返回值时，返回新对象；当指定的返回值不是以上二者时，将返回指定的数据；一般不需要设置返回值
- 新创建的对象都有一个constructor属性，指向创建该实例的构造函数

### 8.对象的分类

- 内建对象
  - 由Eacam提供的对象

- 宿主对象
  - 由运行环境提供的对象
- 自定义对象
  - 开发人员自定义的对象；如各种框架
