# JavaScript基本语法

### 1.输入输出语句

调用prompt()函数，该函数的返回值为字符串，若想输入数字可以进行转换

```
let a = prompt(title，[default]);   //title是显示给用户的内容，而default是输入框中默认显示的内容；返回值为字符串类型
let result = comfirm(question)     //带有是和否两个按钮，并返回true和false
alert("hello")				        //弹出模态窗
```

上述三种方式都会弹出模态窗

```
console.log('hello')		//在控制台输出日志
document.write('hello')		//写入网页
```

### 2.js书写位置

1).<script>标签中

2).写在外部js文件中，然后用<script src="文件路径">引入到网页中，需要注意的是此标签下不能再写js语句

3).直接写在标签的属性中

### 3.书写规范

1).注释与c语言一样

2).严格区分大小写

3).多个空格和回车会被省略

4).语句以分号结尾

### 4.变量与字面量

1).基本概念

js中的变量在使用时不用定义其数据类型，字面量是什么直接用就好了,字面量就是具体的值

2).变量的使用

用let声明然后赋值

3).变量的内存结构

在js中，给变量赋值后，会在内存中开辟一块空间来存放字面量，当此字面量之前就已经存在时，则不会为其开辟内存；变量当中存的是字面量的内存地址，这与指针很相似

### 5.常量

不可以修改，用const声明，本质是锁定变量所指向的内存地址。一般用来定义生活中的常量，但也用来声明一些不希望修改的对象类型的数据

- 对在程序运行前就已知的常量，一般采用大写命名的方式
- 如果是在程序运行当中得知的，一般采用小写命名

### 6.标志符

命名规则大体与c语言相同，只是多了个$可以使用，命名规范类似

### 7.数据类型

> **类型检查**
>
> 使用`typeof`(有无括号都一样)检查变量存储值的类型

#### 1).数值（Nmber）

- 包括整型和实型
- 位数有限制，超过一定范围显示近似值
- Infinity是特殊的数值，表示无穷；NaN也是特殊的数值，表示非法的数值
  - 判断是否是NaN需调用函数isNaN()

#### 2).大整数（BigInt）

- 用于表示非常大的整数，以n结尾       （+-2^53-1）范围之外的数字

**其他进制的数字……**

- 二进制     0b
- 八进制      0o
- 十六进制   0x

显示的 时候仍是十进制，在赋值的时候可以赋上述进制的数

#### 3).字符串（string）

- 字符串用单引号、双引号引起

- 转义字符\

  - \n回车
  - \t制表符
  - \ ' 表示‘ 

- 模板字符串

  - 可以保留空格，换行
  - 可以嵌入变量${a}

- 字符串的方法

  - `str.contact()`                                  拼接多个字符串，返回新字符串

  - `str.includes()`                                 检查字符串中是否包含某个内容

  - `str.indexOf()`                                   检查字符串中是否包含了某个内容；两个参数，要检查的字符串和检查的起始索引；返回索引

  - `str.lastIndexOf()`                           同上，倒着检查

  - `str.endsWith()`                                    检查字符串是否以某个内容结尾

  - `str.startsWith()`                                检查字符串是否以某个内容开始

  - `str.padStart()`

  - `str.padEnd()`                                       两个参数，第一个参数指定字符串长度，第二个参数指定若字符串长度不够，需要补的内容

    **可以传正则**

  - `str.repalceAll()`                               替换所有要被替换的内容；如果正则没有全局模式会报错；

  - `str.replace()`                                     

    - 两个参数，被替换的字符串和进行替换的字符串；返回一个新的字符串；若第一个参数是字符串，只能替换一次；若是传全局模式正则，那么和replaceall一样

      第二个参数:

    - | 符号      | 替换字符串中的行为                                           |
      | :-------- | :----------------------------------------------------------- |
      | `$&`      | 插入整个匹配项                                               |
      | `$``      | 插入字符串中匹配项之前的字符串部分                           |
      | `$'`      | 插入字符串中匹配项之后的字符串部分                           |
      | `$n`      | 如果 `n` 是一个 1-2 位的数字，则插入第 n 个分组的内容，详见 [捕获组](https://zh.javascript.info/regexp-groups) |
      | `$<name>` | 插入带有给定 `name` 的括号内的内容，详见 [捕获组](https://zh.javascript.info/regexp-groups) |
      | `$$`      | 插入字符 `$`                                                 |

  - `str.slice()`

  - `str.substring()`                                   两个参数，起始位置和结束位置（不包括结束位置）；复制指定索引的字符串

  - `str.substr()`                                         两个参数，起始索引和截取的长度

  - `str.split()`                                            将字符串拆分成数组，根据传入的参数拆；**可以根据正则表达式拆分**

  - `str.toLowerCase()`                                将字符串全部转换为小写

  - `str.toUpperCase()`                                将字符串全部转换为大写

  - `str.trim(Start/End)()`                       去除前后空格 

  - `str.match()`                                            

    - 正则普通模式。根据正则匹配内容，若匹配到，则返回一个数组(包括第一个匹配项和分组)；还可以根据 结果的属性index查找匹配位置；属性input查看输入的内容

    - 正则全局模式。返回包含所有匹配项的一个数组

    - 若没有匹配项返回null

  - `str.matchAll()`                                      必须用正则全局模式；返回一个可迭代对象，每一个对象是包含匹配项和捕获组的数组，可用for-of遍历(也可转换为数组Array.from()方法)，其结果跟正则的exec方法返回的内容相同

#### 4).布尔值（Boolean）

- 主要用来进行逻辑判断
- 有true和false两个值

#### 5).空值（Null）

- 表示空对象
- 用typeof无法检查其类型，会返回object

#### 6).未定义（Undefined）

- 值只有undefine
- 与Null的区别：Null是我们去使用的，Undefine是js自己加上去的

#### 7).符号（Symbol）

- 用来创建一个唯一的标识

- ```
  let a = symbol();
  ```

  **原始值一旦创建则不可修改**

- 创建全局symbol

  ```
  let a = symbol.for("id")
  ```

- 查找全局symbol

  ```
  let a = symbol.keyFor("")
  ```

#### 8).对象

##### (1).含义：

##### 一种符合的数据类型，相当于一个容器，用来存放各种数据类型

##### (2).创建对象

(1)`let obj = new object();`其中new可以省略

(2)`let obj = {};`

(3)通过类来创建对象  `let p1 = new Person();`

##### (3).添加/更改/删除对象的属性

> 属性：对象当中的存储的数据
>
> 属性名：(1) 通常是字符串；字符串任意写，当属性是多字词语时，需要加上引号，访问时对象名加[""]
>
> ​				(2)可以是符号（sympol）符号作为属性名,只能通过该变量名去访问对象的属性
>
> ​				(3)可以通过变量来操作属性，需加上[]
>
> 属性值：可以是任意的数据类型
>
> 判断对象中是否有某属性：console.log('name' in obj);

添加属性：(1)`obj.name = 'tom';` `obj.age = 18;`

​					(2)`let newSympol = Sympol();` `obj.[newsympol] = 'tom'`

​					(3)`let obj = {name:'tom',age:18}`

​					(4)对象的最后一个属性应以逗号结尾，这叫尾随或悬挂逗号，这便于我们增加或删除属性

​					(5)属性名和变量名一样时可以简写为一个

更改属性：同上

删除属性：`delete obj.name`     

- 当访问的属性被删除时，会返回undefined

**为对象添加方法时，若属性名和所调用的函数相同，则可以省略属性名；为对象创建方法时可以不用**

##### (4).枚举属性

> 将对象中的属性全部获取

途径：for-in语句

```
let obj = {
	name:'tom',
	age:18,
	adress:'los'
}
for(let propName in obj){
	console.log(propName,obj[propName])				//propName用于接收每次循环的属性
}
```

##### (5).可变类型

- 原始数据是不可变类型，而对象是可变类型，即对象所存储的数据是可以修改的；
- 当两个对象指向同一个地址时，改变其中任意一个变量的属性，另一个变量的属性也会随之改变
- 声明两个对象后，对其进行比较，结果为false，比较两个对象的实质是比较他们的地址

##### (6).注意

- 通常情况下，存储对象的变量用const声明，该声明不允许变量被重新赋值，但对象仍然可以
- 改变量与改对象：改变量指的是修改对象指向的内存地址；改对象指的是修改对象的属性

##### (7).方法

当对象的属性指向函数时，我们此时称函数为对象的方法；调用方法时：对象.方法()

##### (8).window对象

- window对象是由浏览器提供的，属性可以直接访问，用来对浏览器窗口执行操作
- window对象中负责存储js的内置对象和宿主对象
- 函数可以认为是window对象的方法
- 向window对象添加属性可以使其成为全局变量；在代码块中，我们既不使用let声明对象，也不使用var声明对象，则其会成为window对象的属性，即全局变量，极不可取
- var不具有块作用域，但是具有函数作用域；在代码块中用var声明的变量都会成为window对象的属性，即全局变量
- 用function声明的函数都是window对象的方法
- 用let声明的对象不是window对象的属性，无法访问 

### 8.数据类型的强制转换

由于原始值无法改变，因此转换的实质是创建一个新的值

#### 1).转化为字符串

(1).调用tostring()方法

```
let a = 10;
a = a.tostring();		//调用a的tostring方法
```

**由于null与undefine没有tostring方法，故会报错**

(2).调用string()函数

所有类型均适用

#### 2).转化为数值

(1).使用函数Number()

- 纯数字的字符串转换为对应数值
- 非法数字转化为NaN
- 布尔值转换为0/1
- null转换为0
- undefine转换为NaN

(2).针对字符串的转换途径

parseInt与parseFloat  与 [~/0-9]类似，前者还可用来对数值的取整

(3).

| 值              | 变成……                                                       |
| :-------------- | :----------------------------------------------------------- |
| `undefined`     | `NaN`                                                        |
| `null`          | `0`                                                          |
| `true 和 false` | `1` and `0`                                                  |
| `string`        | 去掉首尾空白字符（空格、换行符 `\n`、制表符 `\t` 等）后的纯数字字符串中含有的数字。如果剩余字符串为空，则转换结果为 `0`。否则，将会从剩余字符串中“读取”数字。当类型转换出现 error 时返回 `NaN`。 |

#### (3).转化为布尔值

使用函数Boolean()函数

- 0 null undefined 空字符串 NaN都将转换为false
- 其余的则为true

### 9.运算符

#### 1).算数运算符

- 数字字符串与数值相减，数字字符串自动转换为数值
- 字符串与其他类型的数据做加法，会将其他类型转换为字符串，然后拼串
  - 可以用其他类型的数据加‘ ’来实现转换为字符串，其原理与String()函数相同

- 其他数据类型（除了字符串）与数值进行算数运算时一般会转换为数值再计算

#### 2).赋值运算符

- ？？=   空赋值       当变量为null或undefined时才会进行赋值

#### 3).一元的正负号

- 在数值前加上正号或负号
- 可以用来转换字符串为数值

#### 4).自增自减运算符

- 前置与后置的区别：返回值不同，前置返回现在的值，后置返回以前的值，但无论是前置还是后置，变量的值都已经发生改变
- 只能应用于变量（5++会报错）

#### 5).逻辑运算符

- ！！可以用来将数据转换为布尔值
- &&与||自左向右判断，若&&找到了false，则直接返回false，若都是true，则返回第二个true；||同理
- &&的优先级比||高
- ？？空值合并运算符  返回第一个被定义的变量 ，如果都没有，则返回最后一个值

#### 6).关系运算符

- 当数值与字符串数字比较时，会将字符串数字转换为数值
- 当两个字符串比较时，会逐字符比较字符的Unicode编码，只要有某个字符符合比较条件，就会返回true

#### 7).相等运算符

(1).相等运算符（== / ！=）

- 当两个值类型不同时会自动转换为相同的类型，一般是转换为数值
- null与undefined比较时返回true
- NaN和null在使用==与其他值比对时不会进行转换，而使用其他比较符号时又会进行转换，例如：null==0（false）而null>=0（true）

(2).全等运算符（=== / ！==）

与c语言中的==相同

#### 8).条件运算符（三目运算符）

条件表达式？表达式1：表达式2

#### 9).逗号运算符

只返回最后一个逗号后的值，运算等级比=还低

#### 10).运算符的优先级

### 10.流程控制

#### 1).代码块

用{}来创建代码块，代码块要么都执行，要么都不执行

- let声明的变量具有块作用域，而var声明的变量没有

#### 2).if语句/switch语句

#### 3).循环语句

break/contiune标签 

实现从多层循环中跳出来

- 在需要跳到的循环前加标签
- 在break或continue后面加上该标签

### 11.函数

> 函数也是对象，可以用来存储代码 	

#### 1).函数的创建

- 函数声明

  ```
  function fn(a,b,c){
  
  }
  ```

- 函数表达式

  ```
  const a = function(a,b,c){
  
  }
  ```

- 箭头函数

  ```
  const a = (a,b,c) =>{
  
  }
  ```

  - 当形参少于实参时，多余的实参不会被使用；当形参多于实参时，多余的形参会被赋值为undefined
  - 传入的参数不进行类型检查
  - 声明形参时，可以为其赋默认值，当没有实参时生效
  - 箭头函数在只有一个参数是可以省略括号
  - 对象和函数都可以作为参数传入函数

#### 2).函数的返回值

- 和c语言没什么区别

- 箭头函数的返回值

  ```
  当函数体中只有返回值时，可以简写
  let result = (a,b)=> a+b;
  当返回对象的字面量的时候要加()，因为js解释器会将{}中的内容认为是代码块
  ```

#### 3).作用域

- 全局作用域

  - 全局作用域从打开网页是创建，网页关闭时销毁；其中的变量可以在任意地方被访问

- 局部作用域

  - 局部作用域在运行到该代码块时创建，代码块运行完时销毁；其中的变量仅可以在代码块中被访问

  - 函数作用域

- 作用域链

  在调用变量时，会优先调用最近作用域的变量，最近的作用域没有，则逐级寻找

#### 4).立即执行函数

> 实际开发中，为避免变量被他人意外修改有两种解决方式

- 创建块作用域，将变量声明在块作用域中，尽量不写在全局作用域中

- 定义一个立即执行函数;连写两个立即执行函数时要加分号

  ```
  (function(){
  	let a = 10;
  }())
  ```

#### 5).函数中的this

> 函数在执行时，js解释器会像函数当中传隐含参数this

(1)以函数的形式调用，this指向window

(2)以方法的形式调用，this会指向一个对象，this指向的对象取决于调用方法的对象

(3)构造函数中，this指向新创建的对象

(4)**箭头函数中的this与调用方式无关，定义箭头函数的外层是什么，箭头函数的this就指向谁**

(5)通过call与apply调用的函数，第一个参数可以指定this。

- call的参数列表：第一个是指定的this对象，后面的按原函数参数列表依次写下
- apply的参数列表：第一个是指定的this对象，第二个参数是数组，原参数列表中的参数可依次写入数组中

(7)通过bind调用的函数，会返回新函数，新函数中的this在bind的第一个参数中被锁定，无法更改，bind同时也可以锁死新函数的参数

#### 6).回调函数

当一个函数被用于当做参数传递时，我们成它为回调函数  

#### 7).高阶函数

当一个函数的参数或返回值是函数时，那么这个函数为高阶函数

- 当一个函数的参数是函数时，我们对另一个函数动态的传递代码
- 返回值是函数时，可以动态生成新函数

#### 8).闭包

> 闭包就是能访问到外部函数作用域中变量的函数
>
> 当我们希望隐藏变量时使用闭包

##### (1).闭包的途径

- 创建一个函数声明要隐藏的变量
- 内部函数引用外部函数中的变量
- 将内部函数作为返回值

##### (2).原理

**函数的作用域，在函数创建时就已确定(词法作用域)**

##### (3).闭包的声明周期

当函数被调用时，闭包产生；在内部函数丢失时销毁（内部函数被垃圾回收了，闭包才会消失）

##### (4).注意事项

每调用一次外部函数时，都会产生一个新的闭包，这种做法是占用内存的；类也可以用来隐藏数据，当要大量创建实例时使用类

#### 9).可变参数

`(...num)`，接收多个参数并返回数组        只能放在参数列表的最后

`arguments`   在出箭头函数之外的函数中存在；存储函数的实参，不论函数是否有形参，是一个类数组，可用索引。也可用for-of

### 12.提升

> 在所有代码执行前声明变量（不赋值）或声明函数

(1).变量的提升

​	使用let和var声明变量会使变量提升；区别是let声明的变量即便被提升也无法访问；

(2).函数的提升

​	只有开头使用function声明的函数会被提升

### 14.现代模式

在代码顶部使用`'use strict';`开启现代模式，一旦开启则不能退回到原来的模式，class与module中默认开启