# Javascript

## 输出语句

1. alert("xxx")  ---->警告框

2. console.log('xxx') ---->控制台显示

3. document.write('xxx') ---->网页显示

   三个的区别在于输出位置的不同

## 编写位置

1. 在HTML网页中插入JavaScript代码，写在`<script></script>`之间

2. 可以把HTML文件和JS代码分开,并单独创建一个JavaScript文件(简称JS文件),其文件后缀通常为.js，然后将JS代码直接写在JS文件中。

3. 可以将JavaScript代码放在html文件中任何位置，但是我们一般放在网页的head或者body部分。
   **放在<head>部分**
   最常用的方式是在页面中head部分放置<script>元素，浏览器解析head部分就会执行这个代码，然后才解析页面的其余部分。
   **放在<body>部分**
   JavaScript代码在网页读取到该语句的时候就会执行。

   **注意:** javascript作为一种脚本语言可以放在html页面中任何位置，但是浏览器解释html时是按先后顺序的，所以前面的script就先被执行。比如进行页面显示初始化的js必须放在head里面，因为初始化都要求提前进行（如给页面body设置css等）；而如果是通过事件调用执行的function那么对位置没什么要求的。

## 语法

### 代码格式

```js
语句;
```

一行的结束就被认定为语句的结束，通常在结尾加上一个分号`";"`来表示语句的结束。

**注意:**

1. “;”分号要在英文状态下输入，同样，JS中的代码和符号都要在英文状态下输入。

2. 虽然分号“;”也可以不写，但我们要养成编程的好习惯，记得在语句末尾写上分号。

### 注释

注释内容一般放到需要解释语句的结尾处或周围。

**单行注释，在注释内容前加符号 “//”。**

**多行注释以"/\*"开始，以"\*/"结束。**

### 变量

从编程角度讲，变量是用于存储某种/某些数值的存储器。

**定义变量使用关键字var/let,语法如下：**

```js
var/let 变量名
```

**变量名可以任意取名，但要遵循命名规则:**

  1.变量必须使用字母、下划线(_)或者美元符($)开始。

  2.然后可以使用任意多个英文字母、数字、下划线(_)或者美元符($)组成。

  3.不能使用JavaScript关键词与JavaScript保留字。

**变量要先声明再赋值，如下：**

```js
var mychar;
mychar="javascript";
var mynum = 6;
```

**变量可以重复赋值，如下：**

````js
var mychar;
mychar="javascript";
mychar="hello";
````

**注意:**

1. 在JS中区分大小写，如变量mychar与myChar是不一样的，表示是两个变量。

2. 变量虽然也可以不声明，直接使用，但不规范，需要先声明，后使用。

### 常量

用***const***声明，只能赋值一次，重复赋值会报错（一般用大写字母声明）

### 数据类型（8种）

#### 一、原始值（字面值）

构成各种数据的基石，一旦创建就不能修改，不能表示复杂数据

##### 1、数值（Number）

有限制范围，当超过限值时会显示近似值/科学计数法		可以是小数

##### 2、大整数（Bigint）

用来表示一些比较大的整数（不可以是小数）		使用n结尾，它可以表示的数字范围是无限大

##### 3、字符串（String）

1. 使用单引号或者双引号来表示字符串
2. 转义字符（\）    eg：\ " ---> "      \ ' ---> '   \ \ ---> \    \t--->缩进     \n---->换行
3. 模板字符串（使用反单引号`来表示，可以跨行使用，可以嵌入变量< ${变量名} >）
4. xxx.length    --->获取字符串长度

##### 4、布尔值（Boolean）

主要进行逻辑判断		布尔值只有两个（true和false）

使用typeof检查时会返回 boolean

##### 5、空值（Null）

表示空对象，只有一个null

使用typeof检查时会返回object

##### 6、未定义（Undefined）

声明变量未赋值时，它的值是undefined

使用typeof检查时会返回undefined

##### 7、符号（Symbol）

用来创建一个唯一的标识

##### 类型检查：

typeof 运算符<用来检查不同的值的类型，它会根据不同的值返回不同的结果>

#### 二、引用数据类型

##### 对象（object）

对象中可以存储多个各种类型的数据
对象中存储的数据，我们称为属性
向对象中**添加**属性：对象.属性名=属性值	**读取**对象中的属性：对象.属性名

###### 1、属性名

通常属性名就是一个字符串，所以属性名可以是任何值，没有什么特殊要求

但是如果你的属性名太特殊了，不能直接使用，需要使用[]来设置
虽然如此，但还是强烈建议属性名也按照标识符的规范命名

也可以使用符号(symbol)作为属性名，来添加属性
获取这种属性时，也必须使用symbol
使用symbol添加的属性，通常是那些不希望被外界访问的属性

使用[]去操作属性时，可以使用变量（不需要加引号）

###### 2、in运算符

用来检查对象中是否含有某个属性
**语法**   属性名  in obj
如果有返回true,没有返回false

###### 3、对象字面量

可以直接使用{}来创建对象，使用{}所创建的对象，可以直接向对象中添加属性
**语法：**
{
属性名：属性值，
[属性名]：属性值，
}

###### 4、枚举属性（for-in语句）

枚举属性，指将对象中的所有的属性全部获取
***for-in语句***
**语法：**
for(let propName in对象){
语句...
}
-for-in的循环体会执行多次，有几个属性就会执行几次，
每次执行时，都会将一个属性名赋值给我们所定义的变量
**注意：**并不是所有的属性都可以枚举，比如使用符号添加的属性

eg：![uTools_1672304450252](https://lmy-2.oss-cn-beijing.aliyuncs.com/uTools_1672304450252.png)

###### 5、可变类型

对象属于可变类型
-对象创建完成后，可以任意的添加删除修改对象中的属性
**-注意：**
-当对两个对象进行相等或全等比较时，比较的是对象的内存地址
如果有两个变量同时指向一个对象，
通过一个变量修改对象时，对另外一个变量也会产生影响

###### 6、改对象和改变量

**修改对象**
修改对象时，如果有其他变量指向该对象，则所有指向该对象的变量都会受到影响
**修改变量**
修改变量时，只会影响当前的变量。在使用变量存储对象时，很容易因为改变变量指向的对象，提高代码的复杂度
所以通常情况下，声明存储对象的变量时会使用***const***
**注意：**
const只是禁止变量被重新赋值，对对象的修改没有任何影响

###### 7、方法

当一个对象的属性指向一个函数，那么我们就称这个函数是该对象的方法。调用函数就称为调用对象的方法

### 类型转换

#### 一、转换为字符串

![uTools_1672044147761](https://lmy-2.oss-cn-beijing.aliyuncs.com/uTools_1672044147761.png)

#### 二、转换为数值

1.使用Number()函数来将其他类型转换为数值
	转换的情况：
		字符串：
			如果字符串是一个合法的数字，则会自动转换为对应的数字

​			如果字符串不是合法数字，则转换为NaNI

​			如果字符串是空串或纯空格的字符串，则转换为0

​	   布尔值：
​		   true转换为1，false转换为0

​		   nu1转换为0

​	   	undefined转换为NaN

**专门用来将字符串转换为数值的两个方法**
		***parseInt()一将一个字符串转换为一个整数***

​			解析时，会自左向右读取一个字符串，直到读取到字符串中所有的有效的整数

​			也可以使用parseInt()来对一个数字进行取整

​		***parseFloat()一将一个字符串转换为浮点数***

​			解析时，会自左向右读取一个字符串，直到读取到字符串中所有的有效的整数

#### 三、转换为布尔值

1.使用Boolean()函数来将其他类型转换为布尔值
	转换的情况：
		数字：
			0和NaN转换为false
			其余是true
		字符串：
			空串转换为false
			其余是true
		null和undefined都转换为false
		对象：对象会转换为true
	所有表示空性的没有的错误的值都会转换为false
		0、NaN、空串、null、undefined、false

### 运算

#### 一、算术运算符

**幂运算

js是一门弱类型语言，当进行运算时会通过自动的类型转换来完成运算

当任意一个值和字符串做加法运算时，它会先将其他值转换为字符串，然后再做拼串的操作。可以利用这一特点来完成类型转换，可以通过为任意类型+一个空串的形式来将其转换为字符串，其原理和String()函数相同，但使用起来更加简洁

#### 二、赋值运算符

将右边的值赋值给左边的变量

=	+=	-=	*=	/=	%=	**=	??= <空赋值，只有当变量的值为nulL或undefined时才会对变量进行赋值>

一个变量只有在“=”左边时才是变量，在“=”右边时它是值

大部分的运算符都不会改变变量的值，赋值运算符除外

#### 三、一元的正负

一元的±：+正号（不会改变数值的符号）		-负号（可以对数值进行符号位取反）
当我们对非数值类型进行正负运算时，会先将其转换为数值然后再运算

#### 四、逻辑运算符

**逻辑非：** 

**逻辑与：** 可以对两个值进行与运算
				当&&左右都为true时，则返回true,否则返回false
						与运算是短路的与，如果第一个值为false,则不看第二个值
						与运算是找false的，如果找到false则直接返回，没有false才会返回true
				对于非布尔值进行与运算，它会转换为布尔值然后运算，但是最终会返回原值
						-如果第一个值为false,则直接返回第一个值；如果第一个值为true,则返回第二个值

**逻辑或：** 可以对两个值进行或运算
				当||左右有true时，则返回true,否则返回false
						或运算也是短路的或，如果第一个值为true,则不看第二个值
						或运算是找true,如果找到true则直接返回，没有true才会返回false
				对于非布尔值或运算，它会转换为布尔值然后运算，但是最终会返回原值
						如果第一个值为true,则返回第一个；如果第一个值为false,则返回第二个

#### 五、关系运算符

![uTools_1672134929842](https://lmy-2.oss-cn-beijing.aliyuncs.com/uTools_1672134929842.png)

#### 六、相等运算符

![uTools_1672135549327](https://lmy-2.oss-cn-beijing.aliyuncs.com/uTools_1672135549327.png)

#### 七、条件运算符（三元运算符）

![uTools_1672135971196](https://lmy-2.oss-cn-beijing.aliyuncs.com/uTools_1672135971196.png)

#### 八、运算符的优先级

https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence

在表格中位置越靠上的优先级越高，优先级越高越先执行，优先级一样自左向右执行

### 流程控制

#### 一、代码块

![uTools_1672137053342](https://lmy-2.oss-cn-beijing.aliyuncs.com/uTools_1672137053342.png)



#### 二、判断语句（if...else）

if...else语句是在指定的条件成立时执行代码，在条件不成立时执行else后的代码。

如果if后的添加表达式不是布尔值，会转换为布尔值然后再运算

***语法：***

```js
if(条件)
{ 条件成立时执行的代码 }
else
{ 条件不成立时执行的代码 }
```

#### 三、条件分支语句（switch）

![uTools_1672192164744](https://lmy-2.oss-cn-beijing.aliyuncs.com/uTools_1672192164744.png)

**执行的流程**
switch语句在执行时，会依次将switch后的表达式和case后的表单式进行全等比较
如果比较结果为true,则自当前case处开始执行代码
如果比较结果为false,则继续比较其他case后的表达式，直到找到true为止
如果所有的比较都是false,则执行default后的语句
**注意：**
当比较结果为true时，会从当前case处开始执行代码
也就是说case是代码执行的起始位置
这就意味着只要是当前case后的代码，都会执行
可以使用break来避免执行其他的case

#### 四、循环语句

##### 1、while循环

![uTools_1672192558270](https://lmy-2.oss-cn-beijing.aliyuncs.com/uTools_1672192558270.png)

通常编写一个循环，要有***三个条件***
1.初始化表达式（初始化变量）
2.条件表达式（设置循环运行的条件）
3.更新表单式（修改初始化变量）

##### 2、do-while循环

![uTools_1672193566794](https://lmy-2.oss-cn-beijing.aliyuncs.com/uTools_1672193566794.png)

**和while的区别：**
while语句是先判断再执行
do-while语句是先执行再判断
**实质的区别：**
do-while语句可以确保循环至少执行一次

##### 3、for循环

![uTools_1672195483137](https://lmy-2.oss-cn-beijing.aliyuncs.com/uTools_1672195483137.png)

## 函数（也是一个对象）Function

函数是完成某个特定功能的一组语句。如没有函数，完成任务可能需要五行、十行、甚至更多的代码。这时我们就可以把完成特定功能的代码块放到一个函数里，直接调用这个函数，就省重复输入大量代码的麻烦。

### ***语法：***

```js
function 函数名()
{
     函数代码;
}
```

**说明:**

1. function定义函数的关键字。

2. "函数名"你为函数取的名字。

3. "函数代码"替换为完成特定功能的代码。

### **函数调用:**

函数定义好后，是不能自动执行的，所以需调用它,只需直接在需要的位置写函数就ok了,**代码如下:**

![img](https://lmy-2.oss-cn-beijing.aliyuncs.com/5419430400012de808370459.jpg)

### **函数的定义方式：**

***1.函数声明***
function函数名(){
语句...
}
***2.函数表达式***
const 变量 = function(){
语句...
}
***3.箭头函数***
const 变量 = ()=>{
语句...
}

### 参数

**形式参数**
-在定义函数时，可以在函数中指定数量不等的形式参数（形参）
在函数中定义形参，就相当于在函数内部声明了对应的变量但是没有赋值
**实际参数**
-在调用函数时，可以在函数的()传递数量不等的实参
实参会赋值给其对应的形参
***参数：***
1.如果实参和形参数量相同，则对应的实参赋值给对应的形参
2.如果实参多余形参，则多余的实参不会使用
3.如果形参多余实参，则多余的形参为undefined
***参数的类型***
-JS中不会检查参数的类型，可以传递任何类型的值作为参数

**注：**	当箭头函数只有一个参数时，可以省略（）	

参数可以指定默认值，当调用函数未声明变量时，则使用默认值

#### 对象作为参数：

传递实参时，传递并不是变量本身，而是变量中存储的值

函数每次调用，都会重新创建默认值

#### 函数作为参数：

在JS中，函数也是一个对象（一等函数）
别的对象能做的事情，函数也可以

### 函数的返回值

在函数中，可以通过return关键字来指定函数的返回值
返回值就是函数的执行结果，函数调用完毕返回值便会作为结果返回

任何值都可以作为返回值（包括对象和函数之类）

​	如果return后不跟任何值，则相当于返回undefined
​	如果不写return,那么函数的返回值依然是undefined
return一执行函数立即结束

***箭头函数返回值：***

箭头函数的返回值可以直接写在箭头后
如果直接在箭头后设置对象字面量为返回值时，对象字面量必须使用()括起来

### 作用域

#### 全局作用域

全局作用域在网页运行时创建，在网页关闭时消耗
所有直接编写到script标签中的代码都位于全局作用域中
全局作用域中的变量是全局变量，可以在任意位置访问
局部作用域

#### 块作用域

-块作用域是一种局部作用域
块作用域在代码块执行时创建，代码块执行完毕它就销毁
-在块作用域中声明的变量是局部变量，只能在块内部访问，外部无法访问

### 函数作用域

一函数作用域也是一种局部作用域
函数作用域在函数调用时产生，调用结束后销毁
函数每次调用都会产生一个全新的函数作用域
在函数中定义的变量是局部变量，只能在函数内部访问，外部无法访问

### 作用域链

-当我们使用一个变量时，
JS解释器会优先在当前作用域中寻找变量，
如果找到了则直接使用
如果没找到，则去上一层作用域中寻找，找到了则使用
如果没找到，则继续去上一层寻找，以此类推
如果一直到全局作用域都没找到，则报错xxx is not defined

### Window对象

在浏览器中，浏览器为我们提供了一个window对象，可以直接访问
window对象代表的是浏览器窗口，通过该对象可以对浏览器窗口进行各种操作
除此之外window对象还负责存储JS中的内置对象和浏览器的宿主对象
window对象的属性可以通过window对象访问，也可以直接访问
函数就可以认为是window对象的方法，向window对象中添加的属性会自动成为全局变量

**var用来声明变量，作用和let相同，但是var不具有块作用域**
-在全局中使用var声明的变量，都会作为vindow对象的属性保存
-使用function声明的函数，都会作为window的方法保存
-使用et声明的变量不会存储在window对象中，而存在一个秘密的小地方（无法访问）
var虽然没有块作用域，但有函数作用域

在局部作用域中，如果没有使用var或1et声明变量，则变量会自动成为window对象的属性也就是全局变量

### 提升

#### 变量的提升

使用var声明的变量，它会在所有代码执行前被声明
所以我们可以在变量声明前就访问变量

#### 函数的提升

使用函数声明创建的函数，会在其他代码执行前被创建
所以我们可以在函数声明前调用函数

#### let声明的变量实际也会提升，但是在赋值之前解释器禁止对该变量的访问

### debug

debugger

### 立即执行函数

在开发中应该尽量减少直接在全局作用域中编写代码！
所以我们的代码要尽量编写的局部作用域
如果使用let声明的变量，可以使用{}来创建块作用域

***立即执行函数(IIFE)***
-立即是一个匿名的函数，并它只会调用一次
可以利用IIFE来创建一个一次性的函数作用域，避免变量冲突的问题

### this

函数在执行时，JS解析器每次都会传递进一个隐含的参数，这个参数就叫做this
this会指向一个对象
-this所指向的对象会根据函数调用方式的不同而不同
1.以函数形式调用时，this指向的是window
2.以方法的形式调用时，this指向的是调用方法的对象
通过this可以在方法中引用调用方法的对象

#### 箭头函数：

([参数])=>返回值
**例子：**
无参箭头函数：()=>返回值
一个参数的：a=>返回值
多个参数的：(a,b)=>返回值
只有一个语句的函数：()=>返回值
只返回一个对象的函数：()=>({...})
有多行语句的函数：（)=>{
											return返回值
										}

**箭头函数没有自己的this,它的this有外层作用域决定
箭头函数的this和它的调用方式无关**\

### 严格模式

JS运行代码的模式有两种：
***正常模式***
默认情况下代码都运行在正常模式中，
在正常模式，语法检查并不严格
它的原则是：能不报错的地方尽量不报错
这种处理方式导致代码的运行性能较差
***严格模式***
在严格模式下，语法检查变得严格
1.禁止一些语法
2.更容易报错
3.提升了性能
在开发中，应该尽量使用严格模式，
这样可以将一些隐藏的问题消灭在萌芽阶段，
同时也能提升代码的运行性能



## 面向对象

### **面向对象编程(OOP)**

***1.程序是干嘛的？***
-程序就是对现实世界的抽象（照片就是对人的抽象）
***2.对象是干嘛的？***
-一个事物抽象到程序中后就变成了对象
-在程序的世界中，一切皆对象
***3.面向对象的编程***
面向对象的编程指，程序中的所有操作都是通过对象来完成
-做任何事情之前都需要先找到它的对象

·一个**事物**通常由两部分组成：数据和功能
一个**对象**由两部分组成：属性和方法
事物的**数据**到了对象中，体现为**属性**
事物的**功能**到了对象中，体现为**方法**

### 类

![uTools_1672728742603](https://lmy-2.oss-cn-beijing.aliyuncs.com/uTools_1672728742603.png)

### 属性

类是创建对象的模板，要创建第一件事就是定义类

类的代码块，默认就是严格模式（类的代码块是用来设置对象的属性的，不是什么代码都能写）

![uTools_1672734949008](https://lmy-2.oss-cn-beijing.aliyuncs.com/uTools_1672734949008.png)

### 方法

![uTools_1672736297348](https://lmy-2.oss-cn-beijing.aliyuncs.com/uTools_1672736297348.png)

### 构造函数

![uTools_1672795441911](https://lmy-2.oss-cn-beijing.aliyuncs.com/uTools_1672795441911.png)

### 特点一：封装

![uTools_1672822082356](https://lmy-2.oss-cn-beijing.aliyuncs.com/uTools_1672822082356.png)

在set 属性中可以写验证逻辑		私有属性（加#）只能在类内部访问

### 特点二：多态

![uTools_1672889549791](https://lmy-2.oss-cn-beijing.aliyuncs.com/uTools_1672889549791.png)

### 特点三：继承

![uTools_1672907852264](https://lmy-2.oss-cn-beijing.aliyuncs.com/uTools_1672907852264.png)

![uTools_1672908805645](https://lmy-2.oss-cn-beijing.aliyuncs.com/uTools_1672908805645.png)

![uTools_1672908910332](https://lmy-2.oss-cn-beijing.aliyuncs.com/uTools_1672908910332.png)

### 对象的结构

![uTools_1672921318317](https://lmy-2.oss-cn-beijing.aliyuncs.com/uTools_1672921318317.png)

#### 原型对象（prototype）

![uTools_1672922280808](https://lmy-2.oss-cn-beijing.aliyuncs.com/uTools_1672922280808.png)

所有的同类型对象它们的原型对象都是同一个，
也就意味着，同类型对象的原型链是一样的
**原型的作用：**
	原型就相当于是一个公共的区域，可以被所有该类实例访问
可以将该类实例中，所有的公共属性（方法）统一存储到原型中
这样我们只需要创建一个属性，即可被所有实例访问
	JS中继承就是通过原型来实现的，
当继承时，子类的原型就是一个父类的实例
	在对象中有些值是对象独有的，像属性(name,age,gender)每个对象都应该有自己值，
但是有些值对于每个对象来说都是一样的，像各种方法，对于一样的值没必要重复的创建

#### 修改原型

![uTools_1672925630475](https://lmy-2.oss-cn-beijing.aliyuncs.com/uTools_1672925630475.png)

### instanceof和hasOwnPropert

***instanceof***用来检查一个对象是否是一个类的实例
instanceof检查的是对象的原型链上是否有该类实例
只要原型链上有该类实例，就会返回true
dog->Animal的实例->Object实例->Object原型
-Object是所有对象的原型，所以任何和对象和object进行instanceof运算都会返回true

***in***	-使用in运算符检查属性时，无论属性在对象自身还是在原型中，都会返回true

**对象.hasOwnPropert水属性名)（不推荐使用)**
用来检查一个对象的自身是否含有某个属性
**Object.hasOwn(对象，属性名)**
-用来检查一个对象的自身是否含有某个属性

### new运算符

new运算符是创建对象时要使用的运算符

![uTools_1672927902900](https://lmy-2.oss-cn-beijing.aliyuncs.com/uTools_1672927902900.png)

### 对象分类

***内建对象：***	由ES标准所定义的对象（比如Object 、Function 、String 、Number..）
***宿主对象：***	由浏览器提供的对象（BOM、DOM）
***自定义对象：***	由开发人员自己创建的对象

## 数组

### 简介

![uTools_1672968200088](https://lmy-2.oss-cn-beijing.aliyuncs.com/uTools_1672968200088.png)

### 数组的遍历

任何类型的值都可以成为数组中的元素

创建数组时尽量要确保数组中存储的数据的类型是相同

遍历数组简单理解，就是获取到数组中的每一个元素（使用for循环）

#### for-of语句

![uTools_1672969298681](https://lmy-2.oss-cn-beijing.aliyuncs.com/uTools_1672969298681.png)

### 数组方法

#### Array.isArray()

-用来检查一个对象是否是数组

#### at()

可以根据索引获取数组中的指定元素
at可以接收负索引作为参数

#### concat()

用来连接两个或多个数组
非破坏性方法，不会影响原数组，而是返回一个新的数组

#### indexof()

获取元素在数组中第一次出现的索引
***参数：***
1.要查询的元素
2.查询的其实位置

#### lastIndexof()

获取元素在数组中最后一次出现的位置
***返回值：***
找到了则返回元素的索引，
没有找到返回-1

#### join()

将一个数组中的元素连接为一个字符串
-["孙悟空"，"猪八戒”，"沙和尚”，"唐僧”，"沙和尚"]->"孙悟空，猪八戒，沙和尚，唐僧，沙和尚”
***参数：***
指定一个字符串作为连接符

#### slice()

用来截取数组（非破坏性方法）
***参数：***
1,截取的起始位置（包括该位置）
2.截取的结束位置（不包括该位置）
-第二个参数可以省略不写，如果省略则会一直截取到最后
***一索引可以是负值***
如果将两个参数全都省略，则可以对数组进行浅拷贝（浅复制）

复制必须要产生新的对象
当**调用slice**时，会产生一个新的数组对象，从而完成对数组的复制

**...(展开运算符)**
-可以将一个数组中的元素展开到另一个数组中或者作为函数的参数传递
一通过它也可以对数组进行浅复制

**Object.assign(目标对象，被复制的对象)**
一将被复制对象中的属性复制到目标对象里，并将目标对象返回
一也可以使用展开运算符对对象进行复制

##### 浅拷贝和深拷贝

***浅拷贝(shallow copy)***
一通常对对象的拷贝都是浅拷贝
-浅拷贝顾名思义，只对对象的浅层进行复制（只复制一层）》
如果对象中存储的数据是原始值，那么拷贝的深浅是不重要
-浅拷贝只会对对象本身进行复制，不会复制对象中的属性（或元素）
***深拷贝(deep copy)***
-深拷贝指不仅复制对象本身，还复制对象中的属性和元素
一因为性能问题，通常情况不太使用深拷贝

![uTools_1672973664529](https://lmy-2.oss-cn-beijing.aliyuncs.com/uTools_1672973664529.png)

#### push()

向数组的末尾添加一个或多个元素，并返回新的长度

#### pop()

-删除并返回数组的最后一个元素

#### unshift()

一向数组的开头添加一个或多个元素，并返回新的长度

#### shift()

删除并返回数组的第一个元素

#### splice()

-可以删除、插入、替换数组中的元素
***参数：***
1,删除的起始位置
2.删除的数量
3.要插入的元素
***返回值：***
一返回被删除的元素

#### reverse()

-反转数组

#### sort()

sort用来对数组进行排序（会对改变原数组）
sort默认会将数组升序排列
注意：sort默认会按照Jnicode编码进行排序，所以如果直接通过sort对数字进行排序
可能会得到一个不正确的结果
参数：
一可以传递一个回调函数作为参数，通过回调函数来指定排序规则
(a,b)=>a-b升序排列
(a,b)=>b-a降序排列

#### forEach()

用来遍历数组，它需要一个回调函数作为参数，这个回调函数会被调用多次
数组中有几个元素，回调函数就会调用几次，每次调用，都会将数组中的数据作为参数传递
回调函数中有三个参数：
element---当前的元素
index---当前元素的索引
array---被遍历的数组

#### filter()

将数组中符合条件的元素保存到一个新数组中返回
需要一个回调函数作为参数，会为每一个元素去调用回调函数，并根据返回值来决定是否将元素添加到新数组中
非破坏性方法，不会影响原数组

### 数组去重

```html
<script>
	const arr=[1,2,1,3,2,2,4,5,5,6,7]
	
	//编写代码去除数组中重复的元素

	//分别获取数组中的元素
	for (let i=0;i<arr.length;i++){
		//获取当前值后边的所有值
		for (let j=i+1;j<arr.length;j++){
			//判断两个数是否相等
			if (arr[i]==arr[j]){
				//出现了重复元素，删除后边的元素
				arr.splice(j,1)
				/*当arr[i]和arr[j]相同时，它会自动的删除j位置的元素，然后j+1位置的元素，会变成j位置的元素
				而位置已经比较过了，不会重复比较，所以会出现漏比较的情况
				解决办法，当删除一个元素后，需要将该位置的元素在比较一遍*/
                j--
            }
        }
    }
	console.log(arr)
</script>
```

```html
<script>
	const arr=[1,2,1,3,2,2,4,5,5,6,7]
	//获取数组中的元素
	for (let i=0;i<arr.length;i++){
		const index = arr.indexof(arr[i],i+1)  //检查数组中有没有arr[i]这个元素，i+1表示检查的起始位置
		if(index !==-1){
			//出现重复内容
			arr.splice(index,1)
			i--
        }
	}
	console.log(arr)
</script>
```

```html
<script>
	const arr=[1,2,1,3,2,2,4,5,5,6,7]
	const newArr=[]	//创建一个新数组
	for(let ele of arr){	//ele表示数组arr中的元素
		if(newArr.indexof(ele)===-1){	//检查新数组中是否有这个元素，没有返回-1
			newArr.push(ele)	//将这个元素添加到新数组中
        }
    }        
	console.log(newArr)
</script>
```

### 数组排序

#### 冒泡排序：

![uTools_1672987859877](https://lmy-2.oss-cn-beijing.aliyuncs.com/uTools_1672987859877.png)

```html
<script>
    const arr=[9,1,3,2,8,0,5,7,6,4]
	for (let j=0;j<arr.length -1;j++){
		for (let i 0;i arr.length -1;i++){
			//arr[i]前边的元素arr[i+1]后边元素
			if (arr[i]arr[i 1]){
				//大数在前，小数在后，需要交换两个元素的位置
				let temp=arr[i]//临时变量用了存储arr[i]的值
				arr[i]=arr[i+1]//将arr[i+1]的值赋给arr[i]
				arr[i+1]=temp//修改arr[i+1]的值
            }
        }
    }
	console.log(arr)
</script>
```

#### 选择排序：

![uTools_1672988727951](https://lmy-2.oss-cn-beijing.aliyuncs.com/uTools_1672988727951.png)

```html
<script>
    console.log(arr)
	for(let i=0;i<arr.length;i++){
		for(let j=i+1;j<arr.length;j++){
			if(arr[i]arr[j]){
				//交换两个元素的位置
				let temp = arr[i]
				arr[i] = arr[j]
				arr[j] = temp
            }
        }
    }
	console.log(arr)
</script>
```

### 高阶函数

如果一个函数的参数或返回值是函数，则这个函数就称为高阶函数
	为什么要将函数作为参数传递？（回调函数有什么作用？）		<**回调函数**通常都为匿名函数>
	将函数作为参数，意味着可以对另一个函数动态的传递代码

可以通过高阶函数，来动态的生成一个新函数

### 闭包

闭包就是能访问到外部函数作用域中变量的函数
当我们需要**隐藏一些不希望被别人访问的内容**时就可以使用闭包
***构成闭包的条件：***
1.函数的嵌套
2.内部函数要引用外部函数中的变量
3.内部函数要作为返回值返回

eg：

```js
function outer () {
	let num=0//位于函数作用域中
	return () => {
		num++
		console.log(num）
	}
}
const newFn = outer()
```

#### 原理

函数在作用域，在函数创建时就已经确定的**（词法作用域）**				和调用的位置无关
闭包利用的就是**词法作用域**

**闭包的生命周期：**
1·闭包在外部函数调用时产生，外部函数每次调用都会产生一个全新的闭包
2.在内部函数丢失时销毁（内部函数被垃圾回收了，闭包才会消失）

#### 注意事项

闭包主要用来隐藏一些不希望被外部访问的内容，
这就意味着闭包需要占用一定的内存空间
相较于类来说，闭包比较浪费内存空间（类可以使用原型而闭包不能），
需要**执行次数较少**时，使用闭包
需要**大量创建实例**时，使用类

### 递归

调用自身的函数		递归的作用和循环基本一致

编写递归函数，一定要包含**两个条件：**
1.基线条件一递归的终止条件
2.递归条件一如何对问题进行拆分



### 输出内容（document.write）

可用于直接向HTML输出流写内容

**第一种:输出内容用""括起，直接输出"" 号内的内容。**

```html
<script type="text/javascript">
  document.write("I love JavaScript！"); //内容用""括起来，""里的内容直接输出。
</script>
```

**第二种: 通过变量，输出内容**

```html
<script type="text/javascript">
  var mystr="hello world!";
  document.write(mystr);  //直接写变量名，输出变量存储的内容。
</script>
```

**第三种：输出多项内容，内容之间用+号连接。**

```html
<script type="text/javascript">
  var mystr="hello";
  document.write(mystr+"I love JavaScript"); //多项内容之间用+号连接
</script>
```

**第四种：输出HTML标签，并起作用，标签使用""括起来。**

````html
<script type="text/javascript">
  var mystr="hello";
document.write(mystr+"<br>");//输出hello后，输出一个换行符
  document.write("JavaScript");
</script>
````

**关于JS输出空格问题，如果想要实现输出空格，可以使用特殊字符“ ”实现**

```html
<script type="text/javascript">
  document.write("&nbsp;");//输出空格
</script>
```

### 警告（alert 消息对话框）

**语法：**

```js
alert(字符串或变量);
```

**注:**alert弹出消息对话框(包含一个确定按钮)。

1. 在点击对话框"确定"按钮前，不能进行任何其它操作。

2. 消息对话框通常可以用于调试程序。

3. alert输出内容，可以是字符串或变量，与document.write 相似。

### 确认（confirm 消息对话框）

confirm 消息对话框通常用于允许用户做选择的动作，如：“你对吗？”等。弹出对话框(包括一个确定按钮和一个取消按钮)

**语法：**

```js
confirm(str);
/*str:在消息对话框中要显示的文本  返回值：Boolean值
返回值
当用户点击"确定"按钮时，返回true
当用户点击"取消"按钮时，返回false*/
```

**注:** 通过返回值可以判断用户点击了什么按钮；消息对话框是排它的，即用户在点击对话框按钮前，不能进行任何其它操作。

### 提问（prompt 消息对话框）

**`prompt`**弹出消息对话框,通常用于询问一些需要与用户交互的信息。弹出消息对话框（包含一个确定按钮、取消按钮与一个文本输入框）。

**语法：**

```js
prompt(str1,str2);
/*str1:要显示在消息对话框中的文本，不可修改  str2:文本框中的内容，可以修改
返回值
1. 点击确定按钮，文本框中的内容将作为函数返回值
2. 点击取消按钮，将返回null
```

**注:**在用户点击对话框的按钮前，不能进行任何其它操作。

### 打开新窗口（window.open）

open() 方法可以查找一个已经存在或者新建的浏览器窗口。

**语法：**

```html
window.open([URL], [窗口名称], [参数字符串])
```

**参数说明：**

```
URL：可选参数，在窗口中要显示网页的网址或路径。如果省略这个参数，或者它的值是空字符串，那么窗口就不显示任何文档。
窗口名称：可选参数，被打开窗口的名称。
    1.该名称由字母、数字和下划线字符组成。
    2."_top"、"_blank"、"_self"具有特殊意义的名称。
       _blank：在新窗口显示目标网页
       _self：在当前窗口显示目标网页
       _top：框架网页中在上部窗口中显示目标网页
    3.相同 name 的窗口只能创建一个，要想创建多个窗口则 name 不能相同。
   4.name 不能包含有空格。
参数字符串：可选参数，设置窗口参数，各参数用逗号隔开。
```

**参数表：**

![img](https://lmy-2.oss-cn-beijing.aliyuncs.com/52e3677900013d6a05020261.jpg)

eg：打开http://www.imooc.com网站，大小为300px * 200px，无菜单，无工具栏，无状态栏，有滚动条窗口：

```html
<script type="text/javascript"> window.open('http://www.imooc.com','_blank','width=300,height=200,menubar=no,toolbar=no, status=no,scrollbars=yes')
</script>
```

**注意：**运行结果考虑浏览器兼容问题。

### 关闭窗口（window.close）

**语法：**

```js
window.close();   //关闭本窗口
或
<窗口对象>.close();   //关闭指定的窗口
```

**注意:**上面代码在打开新窗口的同时，关闭该窗口，看不到被打开的窗口。

## DOM

### 了解

文档对象模型DOM（Document Object Model）定义访问和处理HTML文档的标准方法。DOM 将HTML文档呈现为带有元素、属性和文本的树结构

![uTools_1673010896766](https://lmy-2.oss-cn-beijing.aliyuncs.com/uTools_1673010896766.png)

### 获取元素

#### id获取

在网页中，我们通过id先找到标签，然后进行操作。

**语法：**

```js
document.getElementById("id")  //id是大小写敏感的字符串
```

eg:![img](https://lmy-2.oss-cn-beijing.aliyuncs.com/52e4c5950001054207900423.jpg)

**结果:**null或[object HTMLParagraphElement]

![img](https://lmy-2.oss-cn-beijing.aliyuncs.com/52e4c6080001734c03800275.jpg)

**注:获取的元素是一个对象，如想对元素进行操作，我们要通过它的属性或方法。**

*console.dir()打印我们返回的元素对象更好的查看里面的属性和方法*

#### 标签名获取

**语法：**

```js
document.getElementsByTagName("标签名")
或
element.document.getElementsByTagName("标签名")  //element是父元素，后面的标签名是子元素，例如 ul.document.getElementsByTagName("li")
```

1.返回的是获取过来元素对象的集合以伪数组的形式存储的

2.我们想要依次打印里面的元素对象我们可以采取遍历的方式

3.如果页面中只有一个1i返回的还是伪数组的形式

4.如果页面中没有这个元素返回的空的伪数组的形式

**注意：**父元素必须是单个对象（必须指明是哪一个元素对象）.获取的时候不包括父元素自己。

### innerHTML属性

innerHTML 属性用于获取或替换 HTML 元素的内容

**语法：**

```js
Object.innerHTML
```

**注意:**

1.Object是获取的元素对象，如通过document.getElementById("ID")获取的元素。

2.注意书写，innerHTML区分大小写。

​        document.getElementById这个函数返回的是一个元素对象，即Element。mychar被赋值成这个找到的元素对像，那么mychar变量只是一个元素对象，这个对象包含了标签名 + 属性 + 文本内容，想要打印出来里面的文本内容的话，还需要进一步提取，所以还要需要innerHTML这个属性。

eg：

![uTools_1671765442088](https://lmy-2.oss-cn-beijing.aliyuncs.com/uTools_1671765442088.png)

**通过id="con"获取<p> 元素，并将元素的内容输出和改变元素内容，代码如下:**

![uTools_1671765987247](https://lmy-2.oss-cn-beijing.aliyuncs.com/uTools_1671765987247.png)

### 改变HTML样式

**语法：**

```js
Object.style.property=new style;
```

**注意:**Object是获取的元素对象，如通过document.getElementById("id")获取的元素。

**基本属性表（property）:**![img](https://lmy-2.oss-cn-beijing.aliyuncs.com/52e4d4240001dd6c04850229.jpg)

**注意:**该表只是一小部分CSS样式属性，其它样式也可以通过该方法设置和修改。

### 显示和隐藏（display属性）

**语法：**

```js
Object.style.display = value
```

**value取值：**

![img](https://lmy-2.oss-cn-beijing.aliyuncs.com/52e4dba5000179da04110095.jpg)

### 控制类名（className属性）

className 属性设置或返回元素的class 属性。

**语法：**

```js
object.className = classname
```

**作用:**

   1.获取元素的class 属性

2. 为网页内的某个元素指定一个css样式来更改该元素的外观

eg:

[控制类名（className 属性），JavaScript入门篇 教程-慕课网 (imooc.com)](https://www.imooc.com/code/473)

