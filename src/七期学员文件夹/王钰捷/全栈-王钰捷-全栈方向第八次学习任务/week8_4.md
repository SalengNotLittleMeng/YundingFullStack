# 对象

[TOC]



## 对象

js中的一种复合数据类型，它相当于一个容器，在对象中可以存储不同的数据类型，对象中存储的数据称为属性

- 创建对象![image-20230107185855213](https://yunding7.oss-cn-beijing.aliyuncs.com/image-20230107185855213.png)

- 添加属性 对象.属性名=属性值

- 读取属性 对象.属性名

  ​				如果读取的时一个对象中没有的属性，会返回undefined

使用typeof检查对象返回的是object

### 对象字面量

可以直接用{ }来创建对象

使用{}创建的对象可以直接向对象中添加属性

语法：

{

​	属性名：属性值，属性名：属性值...

​	[属性名]：属性值，

}

### 对象的属性

#### 属性名

- 通常属性名就是一个字符串，所以属性名可以时任何值，没有什么特殊要求

- 但如果属性名非常特殊不能直接使用，需使用[" "]来设置（没有.了）

- 使用[]去操作属性时，可以使用变量

  使用.形式添加属性时，不能使用变量

- 也可以使用符号symbol作为属性名来添加属性

  获取这种属性时也必须使用symbol

  用symbol通常设置的时不希望被外界访问的属性

#### 属性值

对象的属性值可以时任意的数据类型，也可以是一个对象

#### in运算符

用来检查对象中是否含有某个属性

语法： 属性名 in obj 

如果有返回true，没有返回false

#### 枚举属性

#### for-in语句

### 可变类型

对象属于可变类型，对象创建完成之后，可以任意添加删除修改对象中的属性

注意：

- 当两个对象进行相等或全等比较时，比较的是对象的内存地址，故会返回false
- 如果有两个变量指向同一个对象时，通过一个变量修改对象时，对另一个变量也会产生影响

#### 变量和对象

- 修改对象时，如果有其他变量指向该对象，则所有指向该对象的变量都会受到影响

- 修改变量时，只会影响当前的变量

- 在使用变量储存对象时，很容易因为改变变量指向的对象，提高代码的复杂度，所以通常情况下，声明储存对象的变量时会使用const

  注意 ：const只是禁止变量被重新赋值，不会影响对象的修改

### 方法

当一个对象的属性指向一个函数时，就称这个函数时该对象的方法，调用函数就是调用对象的方法



## 面向对象

程序--程序就是对现实世界的抽象
对象--事物抽象到程序中后就变成了对象
面向对象的编程--程序中的所有操作都是通过对象来完成
	做任何事情之前都需要先找到它的对象，然后通过对象来完成各种操作

### 类

使用0bject创建对象的问题：1.无法区分出不同类型的对象 2.不方便批量创建对象
在 js 中可以通过类（ class ）来解决这个问题：
1.类是对象模板，可以将对象中的属性和方法直接定义在类中
	定义后，就可以直接通过类来创建对象
2.通过同一个类创建的对象，我们称为同类对象

- 可以使用 instanceof 来检查一个对象是否是由某个类创建
- 如果某个对象是由某个类所创建，则我们称该对象是这个类的实例

语法

​	class 类名 {}

​	const 类名= class {}
通过类创建对象
​	 new 类（)

#### 构造函数

在类中可以添加一个特殊的方法 constructor-构造函数（构造方法）

- 构造函数会在我们调用类创建对象时执行
- 可以在构造函数中，为实例属性进行赋值
- 在构造函数中， this 表示当前所创建的对象

### 面向对象的三种特点

封装--安全性    继承--扩展性    多态--灵活性

#### 封装

对象就是一个用来存储不同属性的容器，它不仅存储属性，还要负责数据的安全直接添加到对象中的属性，并不安全，因为它们可以被任意的修改

- 如何确保数据的安全：

  - 私有化数据
    	将需要保护的数据设置为私有，只能在类内部使用

  - 提供 setter 和 getter 方法来开放对数据的操作

  ​		好处：可以控制属性的读写权限，可以在方法中对属性的值进行验证

- 封装的方式：

  - 属性私有化  加＃

  - 通过 getter 和 setter 方法来操作属性
     get 属性名（）{

    ​	return this .＃属性

    }

     set 属性名（参数）{

    ​	this .＃属性=参数

    }

#### 继承

- 可以通过 extends 关键来完成继承，当一个类继承另一个类时，就相当于将另一个类中的代码复制到了当前类中

- 维承发生时，被继承的类称为父类（超类），继承的类称为子类

  ​	在子类中，可以通过创建同名方法来重写父类的方法

- 通过继承可以减少重复的代码，并且可以在不修改一个类的前提对其进行扩展

  ​	OCP开闭原则﹣程序应该对修改关闭，对扩展开放

#### 多态

### 原型

对象中存储属性的区域实际有两个：

1.对象自身

​	直接通过对象所添加的属性，位于对象自身中

​	在类中通过 x = y 的形式添加的属性，位于对象自身中
2．原型对象（ prototype )

- 在对象中会有一个属性用来存储原型对象，这个属性叫做__proto __
- 原型对象也负责为对象存储属性，当我们访问对象中的属性时，会优先访问对象自身的属性，对象自身不包含该属性时，才会去原型对象中寻找
- 会添加到原型对象中的情况：
  - 在类中通过 xxx (){}方式添加的方法，位于原型中
  - 主动向原型中添加的属性或方法

#### 作用

- 原型就相当于是一个公共的区域，可以被所有该类实例访问，可以将该类实例中，所有的公共属性（方法）统一存储到原型中,这样我们只需要创建一个属性，即可被所有实例访问.
-  js中继承就是通过原型来实现的，当继承时，子类的原型就是一个父类的实例

#### 修改

千万不要通过类的实例去修改原型

### new运算符

new 运算符是创建对象时要使用的运算符
当使用 new 去调用一个函数时，这个函数将会作为构造函数调用

- 使用 new 调用函数时，将会发生这些事：
  1.创建一个普通的 js对象

  2.将构造函数的 prototype 属性设置为新对象的原型
  3.使用实参来执行构造函数，并且将新对象设置为函数中的 this 
  4.如果构造函数返回的是一个非原始值，则该值会作为 new 运算的返回值返回；如果构造函数的返回值是一个原始值或者没有指定返回值，则新的对象将会作为返回值返回通常不会为构造函数指定返回值



## 内建对象

### String

### Number

### Boolean

### Date

### Math

### RegExp



## 宿主对象

### BOM

### DOM



