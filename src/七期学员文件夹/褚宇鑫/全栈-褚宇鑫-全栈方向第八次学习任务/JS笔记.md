JS

alert

**console.log**在控制台中打印

document.write

/*1.新建一个.js文件后*/
<script src=" "></script>

*2.在.html文件中用<script></script>添加相应属性*

*3.在<body></body>中直接添加属性，例如<botton o></botton>*

#### 变量的声明

```
let age = 10
let name = 'Marry'
var
```

**变量中并不存储任何值，而是存储值的内存地址**因为CS中没有像C语言一样的声明字符类型的属性(int)，无法将内存中指定大小的空间创建出来供变量使用，所以在存储变量时会将变量名（标识符）和变量分别开辟空间存储，然后用表格的形式将存储值的内存地址与标识符进行对应存储

如果在声明变量后存储值相同，为节省空间，会将上一个与之相同的的存储值的地址赋予该变量，而不是再创建一个新的空间

#### 常量

const，与变量可以改变不同，常量将地址锁定无法改变

#### 标识符命名规范

在JS中， 所有可以由我们自主命名的内容，都可以认为是一个标识符像，变量名，函数名类名...

使用标识符需要遵循如下的命名规范:

1. 标识符只能含有字母、数字、下划线、$,且不能以数字开头

2.  标识符不能是JS中的关键字和保留字，也不建议使用内置的函数或类名作为变量名

3. 命名规范:

   通常会使用驼峰命名法：

   首字母小写，每个单词开头大写max Length-->maxLength

   borderleftwidth--> borderLeftWidth

   类名会使用大驼峰命名法-首字母大写，每个单词开头大写- maxlength --> MaxLength-

   常量的字母会全部大写- MAX_ L ENGTH

#### 数据类型

##### 数值(Number)

—在JS中所有的整数和浮点数都是Number

—JS中的数值并不是无限大的，但数值超过一定范围后会显示近似值

—Infinite，NaN是一个特殊的数值表示无穷，非法数值

在number后加n为bigint类型，如let a = 1314n

##### 字符串string

在JS中使用单双引号来表示字符串

转义字符 \

模板字符串：使用反单引号表示**特点：可以嵌入变量**

```js
let name = "Marry"
let str = `hello,${name}`
let b = 10
console.log(`b = ${b}`)/*打印结果为：b = 10*/
```

##### 布尔值(Boolean)

-布尔值主要用来进行逻辑判断

-布尔值只有两个true和false

-使用typeof检查一 个 布尔值时会返回" boolean"

##### 空值(Null)

-空值用来表示空对象-空值只有一个null

-使用typeof检查 一个空值时会返回" object"

-使用typeof无法检查空值

##### 未定义(Undefined)

-当声明一个变量而没有赋值时，它的值就是Undefined，Undefined类型的值只有一个就是undefined

-使用typeof检查一个Undefined类型的值时，会返回" undefine

##### 符号(Symbol)

-用来创建一个唯一 的标识

-使用typeof检查符 号时会返回" symbol"

JS中原始值一共有七种1. Number 2. BigInt  3.String  4 . Boolean  5. Null 6.Undefined 7. Symbol

七种原始值是构成各种数据的基石原始值在JS中是不可变类型，一旦创建就不能修改

#### 类型转换

指将一种 数据类型转换为其他类型将其他类型转换为(字符串、数值和布尔值)

##### 1.转换为字符串

a.调用腓toString( )方法将其他类型转换为字符串

——调用xxx的yyy方法--> xxx.yyy()

——由于null和undef ined中没有toString( )所以对这两个东西调用toString( )时会报错

b.调用String( )函数将其他类型转换为字符串 

——调用xxx函数--> xxx( )

##### 2.将其他的数据类型转换为数值

使用Number( )函數来将其他类型转换为数值

转换的情况: 

-字符串:

如果字符串是一个合法的数字，则会自动转换为对应数字

如果字符串不是合法数字，则转换为NaN

如果字符串是空串或纯空格的字符串，则转换为0

-布尔值:- true转换为1， false转换为0

null转换为0

undefined 转换为NaN

**专门用来将字符串转换为数值的两个方法**

**parseInt() **-将一个字符串转换为1个整数

-解析时，会自左向右读取1个字符串，直到读取到字符串中非数字的类型

-也可以使用parseInt()来对一个数字进行取整

**parseFloat()**一将一 个字 符串转换为浮点数-解析时，会自左向右读取一个字符串，直到读取到字符串中

使用Boolean( )函数来将其他类型转换为布尔值

-转换的情况:

​       数字

- 0和NaN转换为false

- -其余是true

  字符串:

- -空串转换为false

- -其余是truenull和undefined都转换为false

  对象:对象会转换为true

## JavaScript-打开新窗口（window.open）

open() 方法可以查找一个已经存在或者新建的浏览器窗口。

**语法：**

```
window.open([URL], [窗口名称], [参数字符串])
```

**参数说明:**

```
URL：可选参数，在窗口中要显示网页的网址或路径。如果省略这个参数，或者它的值是空字符串，那么窗口就不显示任何文档。
窗口名称：可选参数，被打开窗口的名称。
    1.该名称由字母、数字和下划线字符组成。
    2."_top"、"_blank"、"_self"具有特殊意义的名称。
       _blank：在新窗口显示目标网页
       _self：在当前窗口显示目标网页
       _top：框架网页中在上部窗口中显示目标网页
    3.相同 name 的窗口只能创建一个，要想创建多个窗口则 name 不能相同。
   4.name 不能包含有空格。
参数字符串：可选参数，设置窗口参数，各参数用逗号隔开。
```

**参数表:**

**[![img](https://img.mukewang.com/52e3677900013d6a05020261.jpg)](https://img.mukewang.com/52e3677900013d6a05020261.jpg)**

例如:打开http://www.imooc.com网站，大小为300px * 200px，无菜单，无工具栏，无状态栏，有滚动条窗口：

```
<script type="text/javascript"> window.open('http://www.imooc.com','_blank','width=300,height=200,menubar=no,toolbar=no, status=no,scrollbars=yes')
</script>
```

## JavaScript-提问（prompt 消息对话框）

**`prompt`**弹出消息对话框,通常用于询问一些需要与用户交互的信息。弹出消息对话框（包含一个确定按钮、取消按钮与一个文本输入框）。

**语法:**

```
prompt(str1, str2);
```

**参数说明：**

```
str1: 要显示在消息对话框中的文本，不可修改
str2：文本框中的内容，可以修改
```

**返回值:**

```
1. 点击确定按钮，文本框中的内容将作为函数返回值
2. 点击取消按钮，将返回null
```

看看下面代码:

```
var myname=prompt("请输入你的姓名:");
if(myname!=null)
  {   alert("你好"+myname); }
else
  {  alert("你好 my friend.");  }
```

**结果:**

**[![img](https://img.mukewang.com/52e360780001ede107090353.jpg)](https://img.mukewang.com/52e360780001ede107090353.jpg)**



### 对象

对象中可以存储多个各种类型的数据

**为属性向对象中添加属性**:对象.属性名=属性值

**读取对象中的属性**：对象.属性名

**注意**：如果读取的是一个对象中没有的属性不会报错而是undefined

#### 学习对象:

1.明确这个对象代表什么，有什么用
2.如何获取到这个对象
3.如何使用这个对象(对象中的属性和方法)

##### 对象的分类: .

内建对象
由ES标准所定义的对象
比如Object Function String Number ....
宿主对象由浏览器提供的对象,BOM、DOM
自定义对象:由开发入员自己创建的对象

#### 属性名

-通常属性名就是一个字符串，所以属性名可以是任何值，没有什么特殊要求，但是如果你的属性名太特殊了，不能直接使用，需要使用[]来设置虽然如此，但是我们还是强烈建议属性名也按照标识符的规范命名

-也可以使用符号(symbol)作为属性名，来添加属性

获取这种属性时，也必须使用symbol

使用symbol添加的属性，通常是那些不希望被外界访问的属性

-使用[]去操作属性时，可以使用变量属性值

-对象的属性值可以是任意的数据类型，也可以是一个对象

使用typeof检查一个对 象时，会返回object

#### 对象字面量

-可以直接使用{}来创建对象

-使用{}所创建的对象，可以直接向对象中添加属性

-语法:

```js
{
	属性名：属性值，
	[属性名]：属性值
}
```

#### 对象的结构

对象中存储属性的区域实际有两个:

##### 1.对象自身

-直接通过对象所添加的属性，位于对象自身中

-在类中通过x = y的形式添加的属性，位于对象自身中

##### 2.原型对象(prototype)

对象中还有一些内容，会存储到其他的对象里(原型对象)

-在对象中会有一个属性用来存储原型对象，这个属性叫做_ _proto_ _ 原型对象也负责为对象存储属性，当我们访问对象中的属性时，会优先访问对象自身的属性，对象自身不包含该属性时，才会去原型对象中寻找

**会添加到原型对象中的情况**:

1.在类中通过xxx( ){}方式添加的方法，位于原型中

2.主动向原型中添加的属性或方法

```js

```

#### 原型对象

##### 访问一个对象的原型对象：

对象._ _proto_ _
Object. getPrototype0f(对象)
原型对象中的数据:
1.对象中的数据(属性、方法等)

2.constructor (对象的构造函数)
注意:
原型对象也有原型，这样就构成了一条原型链， 根据对象的复杂程度不同，原型链的长度也不同
p对象的原型链: p对象-->原型-->原型--> null
obj对象的原型链: obj对象-->原型--> null

##### 原型链:

-读取对象属性时，会优先对象自身属性，
如果对象中有，则使用，没有则去对象的原型中寻找
如果原型中有，则使用，没有则去原型的原型中寻找
直到找到0bject对象的原型(Object的原型没有原型(为null) )
如果依然没有找到，则返回undefined
作用域链，是找变量的链，找不到会报错
-原型链，是找属性的链，找不到会返回undefined

_所有的同类型对象它们的原型对象都是同一个，
也就意味着，同类型对象的原型链是一样的_

##### 原型的作用:

原型就相当于一个公共的区域，可以被所有该类实例访问，
可以将该类实例中，所有的公共属性(方法)统一存储到原型中
这样我们只需要创建一个属性， 即可被所有实例访问
**JS中继承就是通过原型来实现的**
在对象中有些值是对象独有的，像属性(name， age, gender)每个对象都应该有自己值，
但是有些值对于每个对象来说都是一样的， 像各种方法，对于一样的值没必要重复的创建
obj对象的原型链: obj对象-->原型--> null

_大部分情况下，我们是不需要修改原型对象_
(注意:千万不要通过类的实例去修改原型
1.通过一个对象影响所有同类对象，这么做不合适
2.修改原型先得创建实例，麻烦
3.危险)
处理通过__ proto__ 能访问对象的原型外，还可以通过类的prototype属性，来访问实例的原型,**修改原型时，最好通过通过类去修改**
好处:
1.一修改就是修改所有实例的原型
2.无需创建实例即可完成对类的修改
原则:
1.原型尽量不要手动改
2.要改也不要通过实例对象去改
3.通过类.prototype属性去修改
4.最好不要直接给prototype去赋值

##### instanceof与hasOwn

instanceof用来检查一个对 象是否是一个类的实例

```js
class Animal{}
class Dog extends Animal{}
const dog = new Dog
console.log(dog instanceof Animal)
// console.log( "sayHello" in p)
// console. log( p. hasOwnProperty("sayHello"))
// console.log(dog.__proto__ .__proto__.hasOwnProperty( "hasOwnProperty" ))//true
console.log(0bject.hasOwn(p,"sayHello"))

```



- instanceof检 查的是对象的原型链上是否有该类实例
只要原型链上有该类实例，就会返回true
dog -> Animal的实例-> Object实例 -> object原型
- Object是所有对象的原型，所以任何和对象和Object进行instanceof运算都会返回true
- in
  -使用in运算符检查属性时，无论属性在对象自身还是在原型中，都会返回true
- 对象. hasOwnProperty(属性名) (不推荐使用)
  -用来检查一个对象的自身是否含有某个属性
- object . has0wn(对象，属性名)
  用来检查一个对象的自身是否含有某个属性

#### Window对象

-在浏览器中，浏览器为我们提供了一个window对象， 可以直接访问

- window对象代表的是浏览器窗口，通过该对象可以对浏览器窗口进行各种操作，除此之外window对象还负责存储JS中的内置对象和浏览器的宿主对象
- - window对象的属性可以通过window对象访问，也可以直接访问
  - -函数就可以认为是window对象的方法

#### this

-函数在执行时，JS解析器每次都会传递进一个隐含的参数-这个参数就叫做this

- this会指向一个对象

-  this所指向的对象会根据函数调用方式的不同而不同

  1.以函数形式调用时，this指向的是window

  2.以方法的形式调用时，this指向的是调用方法的对象

  通过this可以在方法中引用调用方法的对象如果某个对象是由某个类所创建，则我们称该对象是这个类的实例

#### 枚举属性

指将对象中的所有的属性全部获取

for- in语句语法:

for(let propName in对象){语句...}

-for- in的循环体会执行多次，有几个属性就会执行几次，每次执行时，都会将一个属性名赋值给我们所定义的变量

**注意**:并不是所有的属性都可以枚举，比如使用符号添加的属性

##### 对象属于可变类型

**-对象创建完成后，可以任意的添加删除修改对象中的属性注意:**

**.当对两个对象进行相等或全等比较时，比较的是对象的内存地址**

**-如果有两个变量同时指向一个对象，通过一 个变量修改对象时，对另外一个变量也会产生影响**

#### 修改对象

-修改对象时，如果有其他变量指向该对象则所有指向该对象的变量都会收到影响修改变量

-修改变量时，只会影响当前的变量

在使用变量存储对象时，很容易因为改变变量指向的对象，提高代码的复杂度，所以通常情况下，声明存储对象的变量时会使用const

**注意:**const只是禁止变量被重新赋值，对对象的修改没有任何影响

### 函数

函数的定义方式:

1.函数声明

```js
function 函数名 (){
    语句...
}
```

2.函数表达式

```js
const 变量 = function(){
	语句...
}
```



#### 箭头函数

```js
() => {
    语句...
}//([参数]) =>返回值
```

例子:

无参箭头函数: () =>返回值

一个参数的: a =>返回值

多个参数的: (a, b) =>返回值

只有一个语句的函数: () =>返回值

只返回一个对象的函数: () => ({...})

有多行语句的函数:()=>{return返回值}

#### [箭头函数和普通函数有什么区别](https://www.ngui.cc/el/544738.html)

##### 箭头函数的this

**注意：1.箭头函数没有自己的this,它的this有外层作用域决定**

**2.箭头函数的this和它的调用方式无关**

#### 构造函数

```js
class Person{
    //构造函数会在我们调用类创建对象时执行
    constructor(name,age,gender){
    //可以在构造函数中为实例属性进行赋值
    //在构造函数中this表示当前所创建的对象
        this.name = name;
        this.age = age;
        this.gender = gender;
    }
}
const p1 = new Person("孙悟空",18,"男");
const p2 = new Person("...",18,"男");
const p3 = new Person("...",18,"男");
console.log(p1);
```



##### 形式参数

-在定义函数时，可以在函数中指定数量不等的形式参数(形参)在函数中定义形参，就相当于在函数内部声明了对应的变量但是没有赋值

实际参数

-在调用函数时，可以在函数的( )传递数量不等的实参

-实参会赋值给其对应的形参

-参数:

1.如果实参和形参数量相同，则对应的实参赋值给对应的形参

2.如果实参多余形参，则多余的实参不会使用

3.如果形参多余实参，则多余的形参为undefined

-参数的类型- JS中不会检查参数的类型，可以传递任何类型的值作为参数

##### var

用来声明变量，作用和let相同， 但是var不具有块作用域

-在全局中使用var声明的变量，都会作为window对象的属性保存

-使用function声明的函数， 都会作为window的方法保存

使用let声明的变量不会存储在window对象中，而存在一个秘密的小地方 (无法访问

- window对象的属性可以通过window对象访问，也可以直接访问
- -函数就可以认为是window对象的方法

##### 变量的提升

-使用var声明的变量，它会在所有代码执行前被声明，所以我们可以在变量声明前就访问变量

函数的提升

-使用函数声明创建的函数，会在其他代码执行前被创建，所以我们可以在函数声明前调用函数

Let声明的变量实际也会提升，但是在赋值之前解释器禁止对该变量的访问

#### 立即执行函数(IIFE)

-立即是一个匿名的函数，并它只会调用一 次

-可以利用IIFE来创建一 - 个-次性的函数作用域，避免变量冲突的问题

```js
( function( ){
let a=10
console.log(111)
}());
```

使用0bject创建对象的问题:

1.无法区分出不同类型的对象

2.不方便批量创建对象

### class(类)

在JS中可以通过类(class) 来解决这个问题:

1.类是对象模板，可以将对象中的属性和方法直接定义在类中定义后，就可以直接通过类来创建对象

2.通过同一个类创建的对象，我们称为同类对象

可以使用instanceof来检查一个对 象是否是由某个类创建如果某个对象是由某个类所创建，则我们称该对象是这个类的**实例**

语法:

```

```

#### 面向对象的特点：

封装（安全性），继承（扩展性），多态（灵活性）

##### 1.封装

—对象就是一个用来存储不同属性的容器

—对象不仅负责存储属性，还要负责数据的安全，直接添加到对象的属性并不安全，因为可以被随意修改

—如何确保数据安全（实现封装的方式）：

- 私有化数据
  - 将需要保护的数据设置为私有，只能在类内部使用

- 提供setter和getter方法来开放数据的操作
  - 可以控制属性的读写权限
  - 可以在方法中对属性的值进行验证

封装主要用来保证数据的安全

```js
class Person{
	//私有化属性
    #name
    #age
    #gender
    constructor(name,age,gender){
        this.#name = name;
        this.#age = age;
        this.#gender = gender;
    }
   // get 属性名{
   //     return this.#属性
   //}
   //set 属性名(参数){
   //     this.#属性 = 参数
   // }
    set age(age){
        //验证属性是否合法
        if(age >= 0){
            this.#age = age 
        }
    }
```

##### 2.多态

##### 3.继承

-可以通过extends关键来完成继承

-当一个类继承另一个类时，就相当于将另一个类中的代码复制到了当前类中(简单理解)

-继承发生时，被继承的类称为父类(超类)，继承的类称为子类

-通过继承可以减少重复的代码，并且可以在不修改一个类的前提对其进行扩 展

一通过继承可以在不修改一个类的情况下对其进行扩展

- 0CP开闭原则-程序应该对修改关闭，对扩展开放

```js
class Animal {
	constructor(name){
		this.name = name;
    }
    sayhello(){
        console.log("动物在叫~")
    }
    //修改原型
    Person.prototype =() => {
        console.log("我在飞")
    }
}
class Cat extends Animal{
    //子类中，可以通过创建同名方法来重写父类方法
    sayhello(){
        console.log("喵喵喵")
    }
}
class Dog extends Animal{
    //重写构造函数
    constructor(name,age){
        //重写时第一行代码必须为super()
        super(name)//调用父类的构造函数
    	this.age = age
    }
    sayhello(){
        //调用父类sayhello
        super.sayhello()//在方法中可以用super调用父类的方法
        console.log("汪汪汪")
    }
}
const dog = new Dog("旺财"，3)
dog.sayhello()
console.log(dog)
//通过类访问实例的原型对象
console.log(Person.prototype)
```

对象中存储属性的区域实际有两个:

1.对象自身

- 直接通过对象所添加的属性，位于对象自身中
- 在类中通过x = y的形式添加的属性，位于对象自身中

2.原型对象(prototype)

对象中还有一些内容，会存储到其他的对象里(原型对象)

-在对象中会有一个属性用来存储原型对象，这个属性叫做__ proto__原型对象也负责为对象存储属性，当我们访问对象中的属性时，会优先访问对象自身的属性，对象自身不包含该属性时，才会去原型对象中寻找

**会添加到原型对象中的情况**:

1.在类中通过xxx( ){}方式添加的方法，位于原型中

2.主动向原型中添加的属性或方法

所有的同类型对象它们的原型对象都是同一个，也就意味着，同类型对象的原型链是一样的
**原型的作用:**
原型就相当于是一个公共的区域，可以被所有该类实例访问，可以将该类实例中，所有的公共属性(方法)统一存储到原型中这样我们只需要创建一个属性， 即可被所有实例访问。
JS中继承就是通过原型来实现的
（在对象中有些值是对象独有的，像属性(name， age, gender)每个对象都应该有自己值，但是有些值对于每个对象来说都是一样的， 像各种方法，对于一样的值没必要重复的创建）
