###### （OOP）   面向对象编程

***面向对象的编程指，程序中的所有操作都是通过对象来完成。做任何事情之前都需要先找到它的对象，然后通过对象来完成操作。***

###### 类

1.在js中可以通过类（class）来解决object创建对象的问题：

（1）类是对象模板，可以将对象中的属性和方法直接定义在类中定义后，就可以直接通过类来创建对象

（2）通过一个类创建的对象，我们称为同类对象

​     可以使用instanceof来检查一个对象是否是由某个类创建

​     如果某个对象是由某个类所创建，则我们称该对象是这个类的实例

###### 属性

类是创建对象的模板，要创建第一件事就是定义类

###### 方法

![image-20221228105659118](https://aaaaaabc.oss-cn-beijing.aliyuncs.com/image-20221228105659118.png)

###### 构造函数

class Person{

​       //在类中可以添加一个特殊的方法constructor

​       //该方法我们称为构造函数

​      //构造函数会在我们调用类创建对象时进行

​      constructor（name，age，gender）{

​           //可以在构造函数中，为实例属性进行赋值

​          //在构造函数中，this表示当前所创建的对象

​          this.name = name

​           this.age = age

​            this.gender = gender



​         }

}

const   p1 = new Person(auda,18,男)

const   p2 = new Person(annn,19,女)

###### 面向对象的特点：封装，继承和多态

***1.封装***

   --对象就是一个用来存储不同属性的容器

   --对象不仅存储属性，还要负责数据的安全

   --直接添加到对象中的属性，并不安全，因为他们可以被任意的修改

   --如何确保数据的安全：

​                    1.私有化数据

​                                   ---将需要保护的数据设置为私有，只能在类内部使用

​                    2.提供setter和getter方法来开放对数据的操作

​                                    ---属性设置私有，通过getter    setter 方法操作属性带来的好处

​                                                  1.可以控制属性的读写权限    2.可以在方法中对属性的值进行验证

![image-20221228152519327](https://aaaaaabc.oss-cn-beijing.aliyuncs.com/image-20221228152519327.png)

***2.多态***

--在JS中不会检查参数的类型，所以这就意味着任何数据都可以作为参数传递

--要 调用某个函数，无需指定的类型，只要对象满足某些条件即可

***3.继承***

---可以通过extends关键词来完成继承

---当一个类继承另一个类时，就相当于将另一个类中的代码复制到了当前类中

---继承发生时，被继承的类称为  父类，继承的类称为    子类

![image-20221228155551762](https://aaaaaabc.oss-cn-beijing.aliyuncs.com/image-20221228155551762.png)

###### 对象的结构

![image-20221229091611398](https://aaaaaabc.oss-cn-beijing.aliyuncs.com/image-20221229091611398.png)

###### 原型对象

访问一个对象的原型对象

​                 对象 . _ _ _proto_ _ _

​                  Object . getPrototypeof(对象)

原型对象中的数据：

​                1.对象中的数据（属性   方法等）

​                 2.constructor（对象的构造函数）

注意：原型对象也有原型，这样就构成了一条原型链，根据对象的复杂程度不同，原型链的长度也不同

​         p对象的原型链：p对象  ---  原型 ---  原型 --- null

​         obj对象的原型链： obj对象 --- 原型 ---null

![image-20221229093628022](https://aaaaaabc.oss-cn-beijing.aliyuncs.com/image-20221229093628022.png)

###### 原型的作用

所有的同类型对象他们的原型对象都是一个，也就意味着，同类型对象的原型链是一样的

原型的作用：原型就相当于是一个公共的区域，可以被所有该类实例访问，可以将该类实例中，所有的公共属性（方法）统一存储到原型中，这样我们只需要创建一个属性，即可被所有实例访问

JS中继承就是通过原型来实现的，当继承时，子类的原型就是一个父类的实例

在对象中有些值是对象独有的，像属性（age name）每个对象都应该有自己值，但是有些值对于每个对象来说都是一样的，像各种方法，对于一样的值没必要重复的创建

###### instanceof 和 hasOwn

in ---使用in运算检查属性时，无论属性在对象自身还是在原型中，都会返回true

Object . hasOwn(对象，属性名)---用来检查一个对象的自身是否含有某个属性

###### new运算符

![image-20221229111517543](https://aaaaaabc.oss-cn-beijing.aliyuncs.com/image-20221229111517543.png)

![image-20221229112226658](https://aaaaaabc.oss-cn-beijing.aliyuncs.com/image-20221229112226658.png)

#                                 数 组

###### 数组的简介

---数组也是一种复合数据类型，在数组可以存储多个不同类型的数据

---数组中存储的是有序的数据，数组中的每个数据都有一个唯一的索引

---索引（index）是一组大于0的整数

---创建数组

​     通过Array（）来创建数组，也可以通过【】来创建数组

---向数组中添加元素

​     数组【索引】 =  元素

---读取数组中的元素

​     数组【索引】

---length

​     ---获取数组长度

​     ---获取的实际值就是数组的最大索引 + 1

​     ---向数组最后添加元素：

​              数组【数组 . length】 =  元素

###### 数组的遍历

![image-20221229153227506](https://aaaaaabc.oss-cn-beijing.aliyuncs.com/image-20221229153227506.png)

***for-of语句***

![image-20221229153957592](https://aaaaaabc.oss-cn-beijing.aliyuncs.com/image-20221229153957592.png)

###### 数组方法介绍

1.***Array . isArray（）***用来检查一个对象是否是数组

2.***at（）*** 可以根据索引获取数组中的指定元素     at可以接收负索引作为参数

3.***concat（）***  用来连接两个或多个数组    

4.***indexOf（）***

5.***lastIndexOf（）***

6.***join()***

7.***slice()***

![image-20221229160837985](https://aaaaaabc.oss-cn-beijing.aliyuncs.com/image-20221229160837985.png)

***8.push()    向数组的末尾添加一个或多个元素，并返回新的长度。***

***9.pop（）删除并返回数组的最后一个元素***

***10.unshift（）向数组的开头添加一个或多个元素，并返回新的长度***

***11.shift（）删除并返回数组的第一个元素***

**12.splice（）---可以删除，插入，替换数组中的元素 ***

​                   ***---参数：1.删除的起始位置2.删除的数量3.要插入的元素***

***13.reverse（）反转数组***

***14.sort（）    ---用来对数组进行排序（会改变原数组）---sort默认将数组升序排列  默认按照Unicode编码进行排序***

​                              *** ---参数：可以传递一个回调函数作为参数，通过回调函数来指定排序规则***

​                                             ***  （a,b）=> a - b  升序排列***

​                                               ***   (a , b) = >b -a   降序排列***

***15.forEach（）  ---用来遍历数组   ---它需要一个回调函数作为参数，这个回调函数会被调用多次   数组中有几个元素，回调函数就会调用几次   每次调用，都会将数组中的数据作为参数传递***

​               ***  回调函数中有三个参数，element 当前的元素  index  当前元素的索引   array  被遍历的数组***

***16.filter（） ---将数组中符合条件的元素保存到一个新的数组中返回***

​                       ***---需要一个回调函数作为参数，会为每一个元素去调用回调函数，并根据返回值来决定是否将元素添加到新数组中***

***17.map（） ---根据当前数组生成一个新数组*****

​                     ***---需要一个回调函数作为参数，回调函数的返回值会成为新数组中的元素***

***18.reduce（） ---可以用来将一个数组中的所有元素整合为一个值***

​                          ***---参数：1.回调函数，通过回调函数来指定合并的规则    2.可选参数，初始值***

![image-20230104111423960](C:\Users\1\AppData\Roaming\Typora\typora-user-images\image-20230104111423960.png)

###### 闭包

***闭包的生命周期：1.闭包在外部函数调用时产生，外部函数每次调用都会产生一个全新的闭包***

注意事项：闭包主要用来一些不希望被外部访问的内容，这就意味着闭包需要占用一定的内存空间           相较于类来说，闭包比较浪费内存空间（类可以使用原型而闭包不能）需要执行次数较少时，使用闭包。需要大量创建实例时，使用类。

###### 递归函数

------调用自身的函数称为递归函数

------递归的作用和循环是基本一致

递归的核心思想就是将一个大的问题拆分为一个一个小的问题，小的问题解决了，大的问题也就解决了。

编写递归函数，一定要包含两个条件：

​          1.基线条件 ---  递归的终止条件

​          2.递归条件  ---  如何对问题进行拆分

###### 可变函数

可变函数，在定义函数时可以将参数指定为可变参数

​         ---可变参数可以接收任意数量实参，并将他们统一存储到一个数组中返回

​         ---可变参数的作用和arguments基本一致，但是也有不同

​                     1.可变参数的名字可以自己指定 2.可变参数就是一个数组，可以直接使用数组的方法 3.可变参数可以配合其他参数一起使用

![image-20230104120826521](C:\Users\1\AppData\Roaming\Typora\typora-user-images\image-20230104120826521.png)

###### call和apply

调用函数除了通过  函数（）这种形式外，还可以通过其他的方式来调用函数

​       比如，我们可以通过调用函数的call（）和apply（）两个方法来调用函数

​           函数.call（）

​           函数.apply（）

​           ---call和apply除了可以调用函数，还可以用来指定函数中的this

​          ---call和apply的第一个参数，将会成为函数的this

​          ---通过call方法调用函数，函数的实参直接在第一个参数后一个一个的列出来

​          ---通过apply方法调用函数，函数的实参需要通过一个数组传递

![image-20230104151005988](C:\Users\1\AppData\Roaming\Typora\typora-user-images\image-20230104151005988.png)

###### bind

bind（）是函数的方法，可以用来创建一个新的函数

​           ---bind可以为新函数绑定this

​           ---bind可以为新函数绑定参数

#### 结构赋值

###### 数组的结构

 结构数组时，可以使用...来设置获取多余的元素

![image-20230104154717887](C:\Users\1\AppData\Roaming\Typora\typora-user-images\image-20230104154717887.png)

可以通过结构赋值来快速交换两个变量的值

![image-20230104154824428](C:\Users\1\AppData\Roaming\Typora\typora-user-images\image-20230104154824428.png)

###### 对象的结构

![image-20230104155512071](C:\Users\1\AppData\Roaming\Typora\typora-user-images\image-20230104155512071.png)

#### 对象的序列化

JSON.stringify（）将一个对象转换为JSON字符串

JSON.parse（）可以将一个JSON格式的字符串转换为JS对象

![image-20230104163951826](C:\Users\1\AppData\Roaming\Typora\typora-user-images\image-20230104163951826.png)

###### map

创建：

​    new Map（）

属性和方法：

​    map.size()  获取map中键值对的数量

​    map.set(key , value)向map中添加键值对

​    map.get(key)  根据key获取值

​    map.delete(key) 删除指定数据

​    map.has(key)  检查map中是否包含指定键

​    map.clear( )删除全部键值对

###### Set

---Set用来创建一个集合

---它的功能和数组类似，不同点在于Set中不能存储重复的数据

---使用方法：创建     ---new Set（）

​                                    ---new  Set（[...]）

​                       方法     ---size 获取数量

​                                   ---add（）添加元素

​                                  ---has（）检查元素

​                                   ---delete（）删除元素

###### Math

生成 0-x之间的随机数  

   Math.round（Math.random() * x）

   Math.floor（Math.random() * (x+1)）

生成 x-y之间的随机数  

   Math.round(Math.random()*(y-x)+x)

###### Date

###### 包装类

在JS中，除了直接创建原始值外，也可以创建原始值的对象

​    通过new String（）可以创建String类型的对象

​	通过new Number（）可以创建Number类型的对象

​	通过new Boolean（）可以创建Boolean类型的对象

![image-20230105112025934](C:\Users\1\AppData\Roaming\Typora\typora-user-images\image-20230105112025934.png)

#### 字符串的方法

![image-20230105152520642](https://aaaaaabc.oss-cn-beijing.aliyuncs.com/image-20230105152520642.png)

###### 正则表达式

---正则表达式用来定义一个规则

---通过这个规则计算机可以检查一个字符串是否符合规则或者将字符串中符合规则的内容提取出来

---正则表达式也是JS中的一个对象，所以要使用正则表达式，需要先创建正则表达式的对象

new RegExp（）可以接收两个参数（字符串）1.正则表达式 2.匹配模式

![image-20230105162533042](https://aaaaaabc.oss-cn-beijing.aliyuncs.com/image-20230105162533042.png)

量词     

​    {m}正好m个

​	{m,}至少m个

​	{m,n}m-n个

​	+ 一个以上，相当于{1，}

​	* 任意数量的a

​	？0-1次 {0，1}

###### re.exec（）----获取字符串中符合正则表达式的内容

###### 字符串的正则表达式

split（）根据正则表达式来对一个字符串进行拆分

search（）可以去搜索符合正则表达式的内容第一次在字符串中出现的位置

replace（）根据正则表达式替换字符串的指定内容

match（）根据正则表达式去匹配字符串的符合要求内容

matchAll（）根据正则表达式去匹配字符串的符合要求内容(必须设置g 全局匹配)

​						他返回的是一个迭代器
