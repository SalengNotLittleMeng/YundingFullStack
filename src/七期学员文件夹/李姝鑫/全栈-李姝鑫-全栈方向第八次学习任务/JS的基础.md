# JS的认识

## 书写位置：JS代码需要编写到script中

-  可以将js编写到网页内部的script标签

​            <!-- <script>

​          <!--  alert("哈哈！")-->

​        </script> -->

- 可以将js编写外部的js文件中，然后通过script标签进行引入

​        <!-- <script src="./script/script.js"></script> -->

​    </head>

​    <body>

- 可以将js代码编写到指定属性中

![image-20221231181858444](https://typorafirst.oss-cn-beijing.aliyuncs.com/image-20221231181858444.png)

## 基本语法

-  alert()用来弹出一个警告框

  console.log()控制台输出语句

  document.write()相当于在body中输出语句

- JS严格区分大小写

- 在JS中多个空格和换行会被忽略，可以利用这个特点来对代码进行格式化

- JS中每条语句都应该以分号结尾

-  JS中具有自动添加分号的机制，所以如果不写分号解释器会自动添加

## 字面量与变量

- 字面量

​         \- 字面量其实就是一个值，它所代表的含义就是它字面的意思

​         \- 比如：1 2 3 4 100 "hello" true null .....

​         \- 在js中所有的字面量都可以直接使用，但是直接使用字面量并不方便

- 变量

​         \- 变量可以用“存储”字面量

​         \- 并且变量中存储的字面量可以随意的修改

​         \- 通过变量可以对字面量进行描述，并且变量比较方便修改

**注意：**在定义变量时要注意let和var的区别，let有区域作用范围，var没有区块作用范围，全局有用

​           而且变量中并不存储任何值，而是存储值的内存地址！

## 常量

在JS中，使用const声明常量，常量只能赋值一次，重复赋值会报错

在JS中除了常规的常量外，有一些对象类型的数据我们也会声明为常量

## 标识符

在JS中，所有可以由我们自主命名的内容，都可以认为是一个标识符
                    像 变量名 函数名 类名...

​                使用标识符需要遵循如下的命名规范：

- 标识符只能含有字母、数字、下划线、$，且不能以数字开头
- 标识符不能是JS中的关键字和保留字，也不建议使用内置的函数或类名作为变量名
- 命名规范：

​            通常会使用驼峰命名法:

​                     \- 首字母小写，每个单词开头大写

​                     \- maxlength --> maxLength

​                     \- borderleftwidth --> borderLeftWidth

​                     \- 类名会使用大驼峰命名法

​                     \- 首字母大写，每个单词开头大写

​                     \- maxlength --> MaxLength

​                     \- 常量的字母会全部大写

​                     \- MAX_LENGTH*/

# 数据类型

## 数值

1. **数值（Number）**

​       \- 在JS中所有的整数和浮点数都是Number类型

​       \- JS中的数值并不是限大的，当数值超过一定范围后会显示近似值

​       \- Infinity 是一个特殊的数值表示无穷

​       \-  精度比较高的运算时要十分注意

​       \-NaN 也是一个特殊的数值，表示非法的数值

2. **大整数（BigInt）**

​          \- 大整数用来表示一些比较大的整数

​          \- 大整数使用n结尾，它可以表示的数字范围是无限大

​          \- a = 99999999999999999999999999999999999999999999999999n

3. **其他进制的数字：**

​          二进制 0b

​          八进制 0o

​          十六进制 0x

## 类型检查

typeof 运算符

​          \- typeof用来检查不同的值的类型

​          \- 它会根据不同的值返回不同的结果

```javascript
console.log(typeof a) 
```



## 字符串

字符串（String）

\- 在JS中使用单引号或双引号来表示字符串

\-转义字符\

​           \\" --> "
​          \\' --> '
​          \\\ --> \\\
​           \t --> 制表符
​           \n --> 换行

   \-模板字符串

   \-使用反单引号` 来表示模板字符串

   \-模板字符串中可以嵌入变量

   \-使用typeof检查一个字符串时会返回 "string"

## 其他的数据类型

1. **布尔值（Boolean）**

​        \- 布尔值主要用来进行逻辑判断

​        \- 布尔值只有两个true 和 false

​        \- 使用typeof检查一个布尔值时会返回 "boolean"

2. **空值 （Null）**

​        \-空值用来表示空对象
​        \-空值只有一个null

​        \-使用typeof检查一个空值时会返回"object"

​        \-使用typeof无法检查空值

3. **未定义（Undefined）**

​        \- 当声明一个变量而没有赋值时，它的值就是Undefined

​        \- Undefined类型的值只有一个就是 undefined

​        \- 使用typeof检查一个Undefined类型的值时，会返回 "undefined"

4. **符号（Symbol）**

​        \- 用来创建一个唯一的标识   

​        \- 使用typeof检查符号时会返回 "symbol"

 JS中原始值一共有七种

​        1.Number

​        2.BigInt

​        3.String

​        4.Boolean

​        5.Null

​        6.Undefined

​        7.Symbol

​        七种原始值是构成各种数据的基石

​          原始值在JS中是不可变类型，一旦创建就不能修改

## 类型转换-字符串

类型转换指将一种数据类型转换为其他类型
              将其他类型转换为（字符串、数值和布尔值）

 转换为字符串
              1.调用toString()方法将其他类型转换为字符串

​                   \- 调用xxx的yyy方法
​                    --> xxx.yyy()

​                   \- 由于null和undefined中没有toString()
​                          所以对这两个东西调用toString()时会报错
​                2.调用String()函数将其他类型转换为字符串

​                    \-调用xxx函数
​                    --> xxx()

​                     \- 原理：
​                            对于拥有toString()方法的值调用String()函数时，
​                                                    实际上就是在调用toString()方法
​                           对于null，则直接转换为"null"
​                           对于undefined，直接转换为"undefined"

## 类型转换-数值

将其他的数据类型转换为数值

1. **使用Number()函数来将其他类型转换为数值**

   ​                    转换的情况：

​                           \-字符串：

​                                        \-如果字符串是一个合法的数字，则会自动转换为对应的数字

​                                        \-如果字符串不是合法数字，则转换为NaN

​                                        \-如果字符串是空串或纯空格的字符串，则转换为0

​                                        \-布尔值：

​                                        \-true转换为1，false转换为0

​                                        \-null 转换为 0

​                                       \-undefined 转换为 NaN

2. **专门用来将字符串转换为数值的两个方法**           
   ​              parseInt() —— 将一个字符串转换为一个整数

​                                \-解析时，会自左向右读取一个字符串，直到读取到字符串中所有的有效的整数个数字进行取整
​                    parseFloat() —— 将一个字符串转换为浮点数 

​                                \-解析时，会自左向右读取一个字符串，直到读取到字符串中所有的有效的小数

## 类型转换-布尔值

使用Boolean()函数来将其他类型转换为布尔值

​                 \-转换的情况：
​                        数字：

​                               \-0 和 NaN 转换为false

​                                \-其余是true

​                        字符串：

​                                \-空串 转换为 false

​                                 \-其余是true

​                         null和undefined 都转换为 false

​                         对象：对象会转换为true

\-所有表示空性的没有的错误的值都会转换为false：
           0、NaN、空串、null、undefined、false

# 运算符

 **运算符（操作符）**：运算符可以用来对一个或多个操作数（值）进行运算

## 算术运算符

​        **算术运算符：**

​                              加法运算符  +

​                               减法运算符  -

​                               乘法运算符  *

​                               除法运算符  /

​                               幂运算  **

​                               模运算，两个数相除取余数  %

​                   \-注意：

​                        \-算术运算时，除了字符串的加法，其他运算的操作数是非数值时，都会转换为数值然后再运算

- JS是一门弱类型语言，当进行运算时会通过自动的类型转换来完成运算

```javascript
a = 10 - '5' // 10 - 5
a = 10 + true // 10 + 1
a = 5 + null // 5 + 0
a = 6 - undefined // 6 - NaN
```

- 当任意一个值和字符串做加法运算时，它会先将其他值转换为字符串， 然后再做拼串的操作

​           可以利用这一特点来完成类型转换

​           可以通过为任意类型 + 一个空串的形式来将其转换为字符串

​            其原理和String()函数相同，但使用起来更加简洁

```javascript
a = 'hello' + 'world'
a = '1' + 2 // "1" + "2"
```

## 赋值运算符

赋值运算符用来将一个值赋值给一个变量
     =

​            \-将符号右侧的值赋值给左侧的变量

​            \-空赋值

​            \-只有当变量的值为null或undefined时才会对变量进行赋值
​     +=

​               \-a += n 等价于 a = a + n

​      -=

​                 \-a -= n 等价于 a = a - n

​      *=

​                 \-a *= n 等价于 a = a * n

​      /=

​                  \-a /= n 等价于 a = a / n

​      %=

​                  \-a %= n 等价于 a = a % n

​     **=

```javascript
 a **= n 等价于 a = a ** n
```

## 一元

一元的±

\+正号

​              \-不会改变数值的符号

\-负号

​                \-可以对数值进行符号位取反

  当我们对非数值类型进行正负运算时，会先将其转换为数值然后再运算

## 自增和自减

1. **++ 自增运算符**

​               \-++ 使用后会使得原来的变量立刻增加1

​               \-自增分为前自增(++a)和后自增(a++)

​              \-无论是++a还是a++都会使原变量立刻增加1

​              \- 不同的是++a和a++所返回的值不同

​              \- a++ 是自增前的值 旧值

​              \-++a 是自增后的值 新值

2. **-- 自减运算符**

​             \-使用后会使得原来的变量立刻减小1
​             \-自减分为前自减(--a)和后自减(a--)

​              \-无论是--a还是a--都会使原变量立刻减少1

​              \-不同的是--a和a--的值不同

​              \-   --a 是新值

​              \-  a-- 是旧值

## 逻辑运算符

1. **! 逻辑非**

​       \-   ! 可以用来对一个值进行非运算
​       \-   它可以对一个布尔值进行取反操作
​                 true --> false
​                 false --> true

​       \-如果对一个非布尔值进行取反，它会先将其转换为布尔值然后再取反

​     可以利用这个特点将其他类型转换为布尔值

2. **类型转换**
   ​                 转换为字符串
   ​                          显式转换
   ​                             String()
   ​                          隐式转换

​                                \+ ""
​                      转换为数值
​                             显式转换
​                                  Number()
​                             隐式转换
​                                     +
​                       转换为布尔值
​                              显式转换
​                                  Boolean()
​                               隐式转换
​                                      !!

3. **&& 逻辑与**

 \-   可以对两个值进行与运算

 \-   当&&左右都为true时，则返回true，否则返回false

\-   与运算是短路的与，如果第一个值为false，则不看第二个值的，如果找到false则直接返回，没有false才会返回true

   \- 对于非布尔值进行与运算，它会转换为布尔值然后运算

​       但是最终会返回原值

   \- 如果第一个值为false，则直接返回第一个值

   \-  如果第一个值为true，则返回第二个值        



4. **|| 逻辑或**

  \-  可以对两个值进行或运算
\-   当||左右有true时，则返回true，否则返回false

 \-  或运算也是短路的或，如果第一个值为true，则不看第二个值,如果找到true则直接返回，没有true才会返回false

  \-  对于非布尔值或运算，它会转换为布尔值然后运算
    但是最终会返回原值

  \-  如果第一个值为true，则返回第一个如果第一个值为false，则返回第二个

## 关系运算符

关系运算符

​    \-  关系运算符用来检查两个值之间的关系是否成立
​       成立返回true，不成立返回false
​                >

\-  用来检查左值是否大于右值
    >=

\-  用来检查左值是否大于或等于右值
    <

\-用来检查左值是否小于右值
    <=

\-用来检查左值是否小于或等于右值

​    **注意**：
​                当对非数值进行关系运算时，它会先将前转换为数值然后再比较 

​                当关系运算符的两端是两个字符串，它不会将字符串转换为数值，而是逐位的比较字符的Unicode编码,利用这个特点可以对字符串按照字母排序  
​                注意比较两个字符串格式的数字时一定要进行类型转换  

## 相等运算符

​    **==**

\-  相等运算符，用来比较两个值是否相等
\-  使用相等运算符比较两个不同类型的值时，
   它会将其转换为相同的类型（通常转换为数值）然后再比较类型转换后值相同也会返回true

\-  null和undefined进行相等比较时会返回true

\-  NaN不和任何值相等，包括它自身

\-   全等运算符，用来比较两个值是否全等

\-   它不会进行自动的类型转换，如果两个值的类型不同直接返回false

\-  null和undefined进行全等比较时会返回false

​            !=

\-  不等，用来检查两个值是否不相等

\- 会自动的进行类型转换

​            !==

\-  不全等，比较两个值是否不全等

\- 不和自动的类型转换

## 条件运算符(三目运算符)

条件运算符

1. **语法**

​        条件表达式 ? 表达式1 : 表达式2

2. **执行顺序：**

​          条件运算符在执行时，会先对条件表达式进行求值判断，

​            如果结果为true，则执行表达式1

​            如果结果为false，则执行表达式2

## 运算符优先级

和数学一样，JS中的运算符也有优先级，比如先乘除和加减。

​      可以通过优先级的表格来[查询运算符的优先级]( https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence)

-  在表格中位置越靠上的优先级越高，优先级越高越先执行，优先级一样自左向右执行


-   优先级我们不需要记忆，甚至表格都不需要看


-  因为()拥有最高的优先级，使用运算符时，如果遇到拿不准的，可以直接通过()来改变优先级即可

# 流程控制

## if语句

流程控制语句可以用来改变程序执行的顺序

- 条件判断语句

- 条件分支语句

- 循环语句

​    if语句

1. **语法：**
   ​                             if(条件表达式){
   ​                              语句...
   ​                              }

2. **执行流程**
   ​                  if语句在执行会先对if后的条件表达式进行求值判断，

​                         如果结果为true，则执行if后的语句

​                         如果为false则不执行

​                        if语句只会控制紧随其后其后的那一行代码，如果希望可以控制多行代码，可以使用{}将语句扩起来

​                        最佳实践：即使if后只有1行代码，我们也应该编写代码块，这样结构会更加的清晰

​                        如果if后的添加表达式不是布尔值，会转换为布尔值然后再运算

## if-else语句

​     **if-else语句**

1. **语法：**
   ​                                   if(条件表达式){
   ​                                    语句...
   ​                                    }else{
   ​                                      语句...
   ​                                     }

2. **执行流程：**

​              if-else执行时，先对条件表达式进行求值判断， 如果结果为true 则执行if后的语句  如果结果为false 则执行else后的语句

​            **if-else if-else语句：**

1. **语法**：
   ​                                   if(条件表达式){
   ​                                  语句...
   ​                                  }else if(条件表达式){
   ​                                   语句...
   ​                                  }else if(条件表达式){
   ​                                    语句...
   ​                                  }else if(条件表达式){
   ​                                    语句...
   ​                                  }else{
   ​                                   语句...
   ​                                  }

2. **执行流程：**
   ​                  if-else if-else语句，会自上向下依次对if后的条件表达式进行求值判断，

​                        如果条件表达式结果为true，则执行当前if后的语句，执行完毕语句结束

​                         如果条件表达式结果为false，则继续向下判断，直到找到true为止

​                         如果所有的条件表达式都是false，则执行else后的语句

注意：

​    if-else if-else语句中只会有一个代码块被执行，  一旦有执行的代码块，下边的条件都不会在继续判断了,  所以一定要注意，条件的编写顺序

## switch语句

switch语句

1. **语法：**
                   switch(表达式){
                   case 表达式:
                      代码...
                      break
                   case 表达式:
                       代码...
                        break
                     case 表达式:
                        代码...
                       break
                    case 表达式:
                       代码...
                        break
                     default:
                       代码...
                       break
                     }

2. **执行的流程**

   switch语句在执行时，会依次将switch后的表达式和case后的表达式进行全等比较

​       如果比较结果为true，则自当前case处开始执行代码

​       如果比较结果为false，则继续比较其他case后的表达式，直到找到true为止

​       如果所有的比较都是false，则执行default后的语句

3. **注意**：
     当比较结果为true时，会从当前case处开始执行代码

​         也就是说case是代码执行的起始位置

​         这就意味着只要是当前case后的代码，都会执行

​         可以使用break来避免执行其他的case

4. **总结**
      switch语句和if语句的功能是重复，switch能做的事if也能做，反之亦然。

​         它们最大的不同在于，switch在多个全等判断时，结构比较清晰

## while语句与do-while语句

do-while循环

​        1.  **语法：**

​          do{

​            语句...

​          }while(条件表达式)



​        2. **执行顺序**：

​          do-while语句在执行时，会先执行do后的循环体， 执行完毕后，会对while后的条件表达式进行判断， 如果为false，则循环终止， 如果为true，则继续执行循环体，以此类推



​          和while的区别：

​            while语句是先判断再执行

​            do-while语句是先执行再判断



​        3.  **实质的区别：**

​              do-while语句可以确保循环至少执行一次

## for语句

1. **for循环与while循环**

                - for循环和while没有本质区别，都是用来反复执行代码
                                - 不同点就是语法结构，for循环更加清晰

   - for循环和while没有本质区别，都是用来反复执行代码
        for循环更加清晰

        2.  **语法：**
                                     for(①初始化表达式; ②条件表达式; ④更新表达式){
                                        ③语句...
                                       }
                       

        3.  执行流程：
                        ① 执行初始化表达式，初始化变量

        ​                    ② 执行条件表达式，判断循环是否执行（true执行，false终止）

        ​                    ③ 判断结果为true，则执行循环体

        ​                    ④ 执行更新表达式，对初始化变量进行修改

        ​                    ⑤ 重复②，知道判断为false为止

        \-  初始化表达式，在循环的整个的生命周期中只会执行1次

        \- for循环中的三达式都可以省略

         \-  使用let在for循环的()中声明的变量是局部变量，只能在for循环内部访问

        \-  使用var在for循环的()中声明的变量可以在for循环的外部访问

        4. 创建死循环的方式：

        ​                                  while(1){}
        ​                                  for(;;){}

## 嵌套循环

当循环发生嵌套时，外层循环每执行一次，内层循环就会执行一个完整的周期

外层循环一般控制高

内层循环一般控制行内的数据

## break和continue语句

break和continue

​        \- break

​          \- break用来终止switch和循环语句

​         \- break执行后，当前的switch或循环会立刻停止

​          \- break会终止离他最近的循环

\- continue

​          \- continue用来跳过当次循环

# 对象

## 对象

**数据类型：**

​        原始值

​          1.数值 Number

​          2.大整数 BigInt

​          3.字符串 String

​          4.布尔值 Boolean

​          5.空值 Null

​          6.未定义 Undefined

​          7.符号 Symbol



**对象**

​          \- 对象是JS中的一种复合数据类型，

​            它相当于一个容器，在对象中可以存储各种不同类型数据



原始值只能用来表示一些简单的数据，不能表示复杂数据

比如：现在需要在程序中表示一个人的信息

## 对象的属性

1. **属性名**

​        \- 通常属性名就是一个字符串，所以属性名可以是任何值，没有什么特殊要求

​          但是如果你的属性名太特殊了，不能直接使用，需要使用[]来设置

​          虽然如此，但是我们还是强烈建议属性名也按照标识符的规范命名

​     \- 也可以使用符号（symbol）作为属性名，来添加属性

​          获取这种属性时，也必须使用symbol

​         使用symbol添加的属性，通常是那些不希望被外界访问的属性

​     \- 使用[]去操作属性时，可以使用变量



​    2.   **属性值**

​                 \- 对象的属性值可以是任意的数据类型，也可以是一个对象

​                    使用typeof检查一个对象时，会返回object

3. **in 运算符**

​        \- 用来检查对象中是否含有某个属性

​        \- 语法 属性名 in obj

​        \- 如果有返回true，没有返回false

## 对象的字面量

1. **对象字面量**

​        \- 可以直接使用{} 来创建对象

​        \- 使用{}所创建的对象，可以直接向对象中添加属性

2.  **语法：**

​          {

​            属性名:属性值,

​            [属性名]：属性值，

​          }

## 枚举类型

1. **定义**：枚举属性，指将对象中的所有的属性全部获取

2. 语法

​            for-in语句

​                   for(let propName in 对象){

​                              语句...

​                   }



\- for-in的循环体会执行多次，有几个属性就会执行几次，

​        每次执行时，都会将一个属性名赋值给我们所定义的变量



\- 注意：并不是所有的属性都可以枚举，比如 使用符号添加的属性

## 可变类型

\- 原始值都属于不可变类型，一旦创建就无法修改

​      \- 在内存中不会创建重复的原始值



\- 对象属于可变类型

​      \- 对象创建完成后，可以任意的添加删除修改对象中的属性

\- 注意：

​        \- 当对两个对象进行相等或全等比较时，比较的是对象的内存地址

​       \- 如果有两个变量同时指向一个对象，

​              通过一个变量修改对象时，对另外一个变量也会产生影响

当修改一个对象时，所有指向该对象的变量都会收到影响

## 改变量和改对象

**修改对象**

​          \- 修改对象时，如果有其他变量指向该对象

​            则所有指向该对象的变量都会受到影响

**修改变量**

​          \- 修改变量时，只会影响当前的变量



​        在使用变量存储对象时，很容易因为改变变量指向的对象，提高代码的复杂度

​          所以通常情况下，声明存储对象的变量时会使用const

注意：

​          const只是禁止变量被重新赋值，对对象的修改没有任何影响

# 函数

## 函数的认识

1. **函数的定义**

​             函数（Function）

​                         \- 函数也是一个对象

​                         \- 它具有其他对象所有的功能

​                         \- 函数中可以存储代码，且可以在需要时调用这些代码

2. **函数的语法**

   - 结构：

   ​             function 函数名(){

   ​             语句...

   ​              }

   - 调用函数：

     ​        \- 调用函数就是执行函数中存储的代码

     ​        \- 语法：

     ​          函数对象()

     

     ​      使用typeof检查函数对象时会返回function

## 函数的创建

1. **函数声明**

​          function 函数名(){

​            语句...

​          }



2. **函数表达式**

​          const 变量 = function(){

​            语句...

​          }



3. **箭头函数**

​          () => {

​            语句...

​          }

<img src="https://typorafirst.oss-cn-beijing.aliyuncs.com/image-20230112101116336.png" alt="image-20230112101116336" style="zoom: 67%;" />

​      无参箭头函数：(   ) => 返回值

​        一个参数的：a => 返回值

​        多个参数的：(a, b) => 返回值



​        只有一个语句的函数：(   ) => 返回值

​        只返回一个对象的函数：(   ) => ({...})

​        有多行语句的函数：(   ) => {

​                                              ....   

​                                            return 返回值

​                                             }

## 函数的参数

### **形式参数与实际参数**

**形式参数(形参)**

​        \- 在定义函数时，可以在函数中指定数量不等的形式参数（形参）

​        \- 在函数中定义形参，就相当于在函数内部声明了对应的变量但是没有赋值

​        **实际参数(实参)**

​           \- 在调用函数时，可以在函数的()传递数量不等的实参

​           \- 实参会赋值给其对应的形参

**$\textcolor{red}{注意：}$**

- 如果实参和形参数量相同，则对应的实参赋值给对应的形参

- 如果实参多余形参，则多余的实参不会使用

- 如果形参多余实参，则多余的形参为undefined
- JS中不会检查参数的类型，可以传递任何类型的值作为参数

### 各个函数中参数的位置

<img src="https://typorafirst.oss-cn-beijing.aliyuncs.com/image-20230112102224384.png" alt="image-20230112102224384" style="zoom:67%;" />

**$\textcolor{red}{注意：(箭头函数)}$**

- 当箭头函数中只有一个参数时，可以省略()

- 定义参数时，可以为参数指定默认值

​       默认值，会在没有对应实参时生效

```javascript
const fn3 = (a=10, b=20, c=30) => {
            console.log("a =", a);
            console.log("b =", b);
            console.log("c =", c);
        }
```

### 对象作为参数

<img src="https://typorafirst.oss-cn-beijing.aliyuncs.com/image-20230112103933216.png" alt="image-20230112103933216" style="zoom: 67%;" />

### 函数作为参数

在JS中，函数也是一个对象（一等函数），别的对象能做的事情，函数也可以

一般经常利用箭头函数来作为另一个函数的参数来传递

### 函数的返回值

​      函数的返回值一般是return后面写的东西，当我们给函数赋予返回值时，这个返回值只是被返回而不是被打印，若我们想打印这个返回值，可以在调用时将其返回值储存在一个变量中，然后打印出这个变量

**$\textcolor{red}{注意：}$**

- 任何值都可以作为返回值使用（包括对象和函数之类）

- 如果return后不跟任何值，则相当于返回undefined

-  如果不写return，那么函数的返回值依然是undefined

-  return一执行函数立即结束

- 箭头函数的返回值可以直接写在箭头后，如果直接在箭头后设置对象字面量为返回值时，对象字面量必须使用()括起来

- ```javascript
  const fn = () => ({name:"孙悟空"})
  ```

### 作用域

1. **定义**：作用域指的是一个变量的可见区域

2. **作用域的分类**

   - **全局作用域**

   ​            \- 全局作用域在网页运行时创建，在网页关闭时消耗

   ​            \- 所有直接编写到script标签中的代码都位于全局作用域中

   ​            \- 全局作用域中的变量是全局变量，可以在任意位置访问

   - **局部作用域**

      \- 块作用域

   ​         \- 块作用域是一种局部作用域

   ​         \- 块作用域在代码块执行时创建，代码块执行完毕它就销毁

   ​         \- 在块作用域中声明的变量是局部变量，只能在块内部访问，外部无法访问

3. **函数作用域**

   ​        \- 函数作用域也是一种局部作用域

   ​        \- 函数作用域在函数调用时产生，调用结束后销毁

   ​        \- 函数每次调用都会产生一个全新的函数作用域

   ​        \- 在函数中定义的变量是局部变量，只能在函数内部访问，外部无法访问

4. **作用域链**

   ​      当我们使用一个变量时， JS解释器会优先在当前作用域中寻找变量，如果找到了则直接使用，如果没找到，则去上一层作用域中寻找，找到了则使用； 如果没找到，则继续去上一层寻找，以此类推，如果一直到全局作用域都没找到，则报错 xxx is not defined

### 立即执行函数

1. 立即执行函数（IIFE）

​             \- 立即是一个**匿名**的函数，并它只会**调用一次**

​             \- 可以利用IIFE来创建一个一次性的函数作用域，**避免变量冲突**的问题

2. **语法：**

   ```javascript
   (function(){
               let a = 20
               console.log(a)
           }())
   ```

   

### this

1. **定义：**函数在执行时，JS解析器每次都会传递进一个隐含的参数，这个参数就叫做 this

2. **this指向的对象**

​            this所指向的对象会根据函数调用方式的不同而不同

​                      1.以函数形式调用时，this指向的是window

​                      2.以方法的形式调用时，this指向的是调用方法的对象

3. 箭头函数的this

   ​     \-  箭头函数没有自己的this，它的this有外层作用域决定

   ​     \-   箭头函数的this和它的调用方式无关

### 严格模式

**JS代码运行的方式:**

1. **正常模式**

   ​          \- 默认情况下代码都运行在正常模式中，

   ​                 在正常模式，语法检查并不严格

   ​                 它的原则是：能不报错的地方尽量不报错

   ​          \- 这种处理方式导致代码的运行性能较差

2. 严格模式

   \- 在严格模式下，语法检查变得严格

   - 禁止一些语法

   - 更容易报错

   - 提升了性能

**语法**：

​         "use strict"（可将其写到全局里，让全局使用严格模式；也可将其写到函数里，让函数使用严格模式）

# 面向对象

## 面向对象编程的介绍

**面向对象的编程**

​          \- 面向对象的编程指，程序中的所有操作都是通过对象来完成

​          \- 做任何事情之前都需要先找到它的对象，然后通过对象来完成各种操作

**属性与方法的认识**

​        \- 一个事物通常由两部分组成：数据和功能

​        \- 一个对象由两部分组成：属性和方法

​        \- 事物的数据到了对象中，体现为属性

​        \- 事物的功能到了对象中，体现为方法

## 类

1. **在JS中可以通过类（class）来批量创建对象：**

   1. 类是对象模板，可以将对象中的属性和方法直接定义在类中

      定义后，就可以直接通过类来创建对象

   2.  通过同一个类创建的对象，我们称为同类对象

      可以使用instanceof来检查一个对象是否是由某个类创建

       如果某个对象是由某个类所创建，则我们称该对象是这个类的实例

2. **语法：**

   - class 类名 {   } // 类名要使用大驼峰命名

   - const 类名 = class {   }

3. 通过类创建对象

   ​          new 类名()

## 构造函数

在类中可以添加一个特殊的方法constructor，该方法我们称为构造函数（构造方法），构造函数会在我们调用类创建对象时执行。

例如：

```javascript
class Person{
            constructor(name, age, gender){
                // 可以在构造函数中，为实例属性进行赋值
                // 在构造函数中，this表示当前所创建的对象
                this.name = name
                this.age = age
                this.gender = gender
            }
        }

        const p1 = new Person("孙悟空", 18, "男")
        const p2 = new Person("猪八戒", 28, "男")
        const p3 = new Person("沙和尚", 38, "男")

        console.log(p1)
        console.log(p2)
        console.log(p3)
```

## 封装

![74.封装](https://typorafirst.oss-cn-beijing.aliyuncs.com/74.%E5%B0%81%E8%A3%85.png)

## 多态

​        \- 在JS中不会检查参数的类型，所以这就意味着任何数据都可以作为参数传递

​        \- 要调用某个函数，无需指定的类型，只要对象满足某些条件即可

​        \- 如果一个东西走路像鸭子，叫起来像鸭子，那么它就是鸭子

​        \- 多态为我们提供了灵活性

## 继承

1. **定义：**当一个类继承另一个类时，就相当于将另一个类中的代码复制到了当前类中

2. **语法**

   可以通过extends关键来完成继承

   ```javascript
   class Animal{
               constructor(name){
                   this.name = name
               }
   
               sayHello(){
                   console.log("动物在叫~")
               }
           }
   
           class Dog extends Animal{
               }
   const dog = new Dog("旺财")
   dog.sayHello( )
   console.log(dog)
   ```

   继承发生时，被继承的类称为 父类（超类），继承的类称为 子类

   通过继承可以减少重复的代码，并且可以在不修改一个类的前提对其进行扩展

3. **修改或引用父类的引用**

​           **继承**

​                       \- 通过继承可以在不修改一个类的情况下对其进行扩展

​                       \- OCP 开闭原则

​                               \- 程序应该对修改关闭，对扩展开放

**修改**：在子类中，可以通过创建同名方法来重写父类的方法

**重写构造函数**：重写构造函数时，构造函数的第一行代码必须为super()

例如：

```javascript
class Animal{
            constructor(name){
                this.name = name
            }

            sayHello(){
                console.log("动物在叫~")
            }
        }
class Cat extends Animal{
            // 重写构造函数
            constructor(name, age){
                // 重写构造函数时，构造函数的第一行代码必须为super()
                super(name) // 调用父类的构造函数
                this.age = age

            }
            sayHello(){

                // 调用一下父类的sayHello
                super.sayHello() // 在方法中可以使用super来引用父类的方法

                console.log("喵喵喵")
            }
        }
```

**super：**

1. 我们可以利用它调用父类的构造函数
2. 我们可以利用它来引用父类的方法

## 对象的结构

1. 对象中存储属性的区域实际有两个：

   1. **对象自身**

   ​            \- 直接通过对象所添加的属性，位于对象自身中

   ​            \- 在类中通过 x = y 的形式添加的属性，位于对象自身中

   2. **原型对象（prototype）**

   ​            \- 对象中还有一些内容，会存储到其他的对象里（原型对象）

   ​            \- 在对象中会有一个属性用来存储原型对象，这个属性叫做__proto__

   ​            \- 原型对象也负责为对象存储属性，

   ​                      当我们访问对象中的属性时，会优先访问对象自身的属性，

   ​                      对象自身不包含该属性时，才会去原型对象中寻找

   ​          \- 会添加到原型对象中的情况：

   ​                    1. 在类中通过xxx(){}方式添加的方法，位于原型中

   ​                    2. 主动向原型中添加的属性或方法

2. **原型对象与对象自身之间的关系**

<img src="https://typorafirst.oss-cn-beijing.aliyuncs.com/image-20230112160009259.png" alt="image-20230112160009259" style="zoom: 67%;" />

我们可以将某一个类下所有对象所需的属性都写到这个原型对象中，这样可以最大程度上减少代码量，也可以让每一个对象都具有这些属性和方法。

3. **访问原型对象的方式**
   - 对象.______proto______
   - Object.getPrototypeOf(对象)
   - 构造函数.prototype

4. **原型链**

   - **定义**：原型对象也有原型，这样就构成了一条原型链，根据对象的复杂程度不同，原型链的长度也不同

   - \- 读取对象属性时,会优先对象自身属性,

     ​              如果对象中有,则使用,没有则去对象的原型中寻找

     ​              如果原型中有,则使用,没有则去原型的原型中寻找

     ​              直到找到Object对象的原型(Object的原型没有原型(为null))

     ​                如果依然没有找到,则返回undefined

     \- 作用域链,是找变量的链,找不到会报错

      \- 原型链,是找属性的链,找不到会返回undefined

   - ```javascript
     class Person {
                     name = "孙悟空"
                     age = 18
     
                     sayHello() {
                         console.log("Hello，我是", this.name)
                     }
                 }
     
                 const p = new Person()
                 const obj = {} 
     ```

     p对象的原型链：p对象 --> 原型 --> 原型 --> null

     obj对象的原型链:obj对象 --> 原型 --> null

5. 原型的修改

   大部分情况下，我们是不需要修改原型对象；

   但要修改时千万不要通过类的实例去修改原型

   原因：通过一个对象影响所有同类对象，这么做不合适

   ​            修改原型先得创建实例，麻烦

   ​            容易出差错

   **修改原型时，最好通过通过类去修改**

   好处：

   ​            1. 一修改就是修改所有实例的原型

   ​            2. 无需创建实例即可完成对类的修改

   原则：

                              1. 原型尽量不要手动改
                              2. 要改也不要通过实例对象去改
                              3. 通过 类.prototype 属性去修改
                              4. 最好不要直接给prototype去赋值

   原因：（将修改原型与修改人类的基因作比）

   - 通过类去改原型：从根源上改变基因

   - 通过对象修改原型：在改变一个人基因的同时，修改了所有人的基因，这是不合理的

   - 所以我们在修改原型时，要使用类去改变对象

     例如：

     <img src="https://typorafirst.oss-cn-beijing.aliyuncs.com/image-20230112162339624.png" alt="image-20230112162339624" style="zoom: 50%;" />

     

6. instanceof和hasOwn

   1. **instanceof**

      instanceof 用来检查一个对象是否是一个类的实例

      ​        \- instanceof检查的是对象的原型链上是否有该类实例

      ​             只要原型链上有该类实例，就会返回true

      **$\textcolor{red}{注意：}$**Object是所有对象的原型，所以任何和对象和Object进行instanceof运算都会返回true

   2. in

      ​          \- 使用in运算符检查属性时，无论属性在对象自身还是在原型中，都会返回true

   3. 对象.hasOwnProperty(属性名) (不推荐使用)

      ​          \- 用来检查一个对象的自身是否含有某个属性

   4. Object.hasOwn(对象, 属性名) 

      ​          \- 用来检查一个对象的自身是否含有某个属性

# 数组

## 数组的认识

任何类型的值都可以成为数组中的元素

length

- 获取数组的长度

- 获取的实际值就是数组的最大索引 + 1

- 向数组最后添加元素：

​           数组[数组.length] = 元素

- length是可以修改的
- 直接使用数组名.length即可获取数组的长度

## 遍历数组

1. 利用for循环遍历整个数组

2. for-of语句

   语法：

   ​          for(变量 of 可迭代的对象){

   ​            语句...

   ​          }

   每次执行时都会将一个元素赋值给变量

## 数组常用的方法

1. **Array.isArray(数组名)**

   ​          \- 用来检查一个对象是否是数组

2. **at(索引)**

   ​          \- 可以根据索引获取数组中的指定元素

   ​          \- at可以接收负索引作为参数

3. **concat(数组1，数组2)**

   ​          \- 用来连接两个或多个数组

   ​          \- 非破坏性方法，不会影响原数组，而是返回一个新的数组

   **注意：**括号里既可写数组名也可写数组整体

4.  **indexOf(要查询的元素,查询的起始位置)**

   \-  获取元素在数组中第一次出现的索引


5. **lastIndexOf()**

   ​          \- 获取元素在数组中最后一次出现的位置

   ​          \- 返回值： 找到了则返回元素的索引，没有找到返回-1

6. **join()**

   ​          \- 将一个数组中的元素连接为一个字符串

   ​          \- ["孙悟空", "猪八戒", "沙和尚", "唐僧", "沙和尚"] -> "孙悟空,猪八戒,沙和尚,唐僧,沙和尚"

​                 \- 默认中间以","为连接符，也可以将指定符号放入括号内

​                 \- 参数：指定一个字符串作为连接符

​                 \-  数组名.join(指定符号)

7. **push()**

​        \- 向数组的末尾添加一个或多个元素，并返回新的长度

8. **pop()**

​        \- 删除并返回数组的最后一个元素

9. **unshift()**

​        \- 向数组的开头添加一个或多个元素，并返回新的长度

10. **shift()**

​        \- 删除并返回数组的第一个元素

11. **splice()**

​        \- 可以删除、插入、替换数组中的元素

​         \- 参数：

​                1. 删除的起始位置

​                2. 删除的数量

​                3. 要插入的元素

​          \- 返回值：

​                 \- 返回被删除的元素

<img src="https://typorafirst.oss-cn-beijing.aliyuncs.com/image-20230112165016101.png" alt="image-20230112165016101" style="zoom:67%;" />

12. **reverse()**

​        \- 反转数组(颠倒数组中元素的顺序)

13. **slice(截取的起始位置（包括该位置）, 截取的结束位置（不包括该位置）)**

    ​          \- 用来截取数组（非破坏性方法）

    ​          \-  参数：  第二个参数可以省略不写，如果省略则会一直截取到最后,索引可以是负值

    **注意**：如果将两个参数全都省略，则可以对数组进行浅拷贝（浅复制）

14. **sort()**

    \- sort用来对数组进行排序（会对改变原数组）

    \- sort默认会将数组升序排列

    ​              注意：sort默认会按照Unicode编码进行排序，所以如果直接通过sort对数字进行排序

    ​                  可能会得到一个不正确的结果

    \- 参数：

    ​            \- 可以传递一个回调函数作为参数，通过回调函数来指定排序规则

    ​              (a, b) => a - b 升序排列

    ​              (a, b) => b - a 降序排列

15. **forEach()**

    ​          \- 用来遍历数组

    ​          \- 它需要一个回调函数作为参数，这个回调函数会被调用多次

    ​                 数组中有几个元素，回调函数就会调用几次

    ​                 每次调用，都会将数组中的数据作为参数传递

    ​          \- 回调函数中有三个参数：(在写参数那个括号里这三个元素是按顺序排列的，但log时是按照参数括号里定义的名字输出时排列的顺序输出的)

    ​            element 当前的元素

    ​            index 当前元素的索引

    ​            array 被遍历的数组

16. **filter()**

    ​          \- 将数组中符合条件的元素保存到一个新数组中返回

    ​          \- 需要一个回调函数作为参数，会为每一个元素去调用回调函数，并根据返回值来决定是否将元素添加到新数组中

    ​          \- 非破坏性方法，不会影响原数组

17. **map()**

    ​          \- 根据当前数组生成一个新数组

    ​          \- 需要一个回调函数作为参数，

    ​            回调函数的返回值会成为新数组中的元素

    ​          \- 非破坏性方法不会影响原数组

18. **reduce()**

    \-  可以用来将一个数组中的所有元素整合为一个值

    \- 参数：

    1. 回调函数，通过回调函数来指定合并的规则
    2. 可选参数，初始值

# 正则表达式

## 正则表达式的介绍

正则表达式

​          \- 正则表达式可以用来定义一个规则

​          \- 通过这个规则计算机可以检查一个字符串是否符合规则

​            或者将字符串中符合规则的内容提取出来

​          \- 正则表达式也是JS中的一个对象，

​            所以要使用正则表达式，需要先创建正则表达式的对象

## 正则表达式的语法

```javascript
var  regexp_1 = /a/;//匹配字符‘a’，且没有特殊的匹配规则。
var  regexp_2 = new Regexp("a"); 
```

1. 三种匹配规则

   | **匹配规则符号** | **规则含义**                                                 |
   | ---------------- | ------------------------------------------------------------ |
   | i                | 匹配时**忽略大小写**                                         |
   | g                | 执行全局匹配(会**匹配整个语句**，而非匹配到第一个目标后终止) |
   | m                | 执行**多行匹配**                                             |

   ```javascript
   var  regexp_1 = /a/i;
   
   var  regexp_4 = new Regexp("a","i");
   
   var  regexp_7 = new Regexp("a","igm"); 
   var  regexp_8 = /a/igm; 
   ```

   对于**第一种正则表达式**，我们**直接在斜线后加上匹配规则对应的符号**即可；

   对于**第二种正则表达式**，我们**在括号里传入第二个参数**即可，**参数仍然是对应的符号；**

   **注意：**：其实**不传入参数、斜线后面不写任何东西，代表了默认情况，也就是普通的正则匹配**

2. 在正则表达式中大部分字符都可以直接写

2. | 在正则表达式中表示或

3. [] 表示或（字符集）
   [a-z] 任意的小写字母
   [A-Z] 任意的大写字母
   [a-zA-Z] 任意的字母
   [0-9]任意数字

4. [^] 表示除了

   ​          `[^x] `除了x

5. . 表示除了换行外的任意字符

6. 在正则表达式中使用\作为转义字符

7. 其他的字符集

​          \w 任意的单词字符 [A-Za-z0-9_]

​          \W 除了单词字符 `[^A-Za-z0-9_]`

​          \d 任意数字 [0-9]

​          \D 除了数字 `[^0-9]`

​          \s 空格

​          \S 除了空格

​          \b 单词边界

​          \B 除了单词边界

8. 开头和结尾

​          ^ 表示字符串的开头

​          $ 表示字符串的结尾

## 正则表达式的方法

1. **test() 方法**是正则表达式最常用一个方法，**用于检测一个字符串是否匹配某个模式**.

   语法：let   变量名 = 正则表达式名.test.（要查验的字符串名）

   ```javascript
   let boolean_value = regexp.test(regexp)
   ```

   

2. **exec() 方法**用于**检索字符串中的正则表达式的匹配。**

   **re.exec()**

   ​          \- 获取字符串中符合正则表达式的内容
