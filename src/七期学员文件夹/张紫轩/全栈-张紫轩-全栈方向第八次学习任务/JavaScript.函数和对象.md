### 逻辑运算符（补充）

**&&**\- 可以对两个值进行与运算

当&&左右都为true时，则返回true，否则返回false

与运算是短路的与，如果第一个值为false，则不看第二个值

与运算是找false的，如果找到false则直接返回，没有false才会返回true

对于非布尔值进行与运算，它会转换为布尔值然后运算

**但是最终会返回原值**

如果第一个值为false，则直接返回第一个值

如果第一个值为true，则返回第二个值

**||** \- 可以对两个值进行或运算

当||左右有true时，则返回true，否则返回false

或运算也是短路的或，如果第一个值为true，则不看第二个值

或运算是找true，如果找到true则直接返回，没有true才会返回false

 对于非布尔值或运算，它会转换为布尔值然后运算

**但是最终会返回原值**

如果第一个值为true，则返回第一个，如果第一个值为false，则返回第二个

### 代码块（补充）

使用 {} 来创建代码块，代码块可以用来对代码进行分组，同一个代码中的代码，就是同一组代码，一个代码块中的代码要么都执行要么都不执行

在JS中，**使用let声明**的变量具有块作用域在代码块中声明的变量无法在代码块的外部访问

**使用var声明**的变量，不具有块作用域

## 对象

**数据类型：**

​        **原始值**

​          **1.数值 Number**

​          **2.大整数 BigInt**

​          **3.字符串 String**

​          **4.布尔值 Boolean**

​          **5.空值 Null**

​          **6.未定义 Undefined**

​          **7.符号 Symbol**

**对象**

​          \- 对象是JS中的一种复合数据类型，它相当于一个容器，在对象中可以存储各种不同类型数据

对象中可以存储多个各种类型的数据， 对象中存储的数据，我们称为属性

向对象中添加属性：

​        对象.属性名 = 属性值

读取对象中的属性

​        对象.属性名

  \- 如果读取的是一个对象中没有的属性，不会报错而是返回undefined

**原始值只能用来表示一些简单的数据，不能表示复杂数据**

// 创建对象

​    `let obj = Object()`

#### 对象的属性

**属性名**

\- 通常属性名就是一个字符串，所以属性名可以是任何值，没有什么特殊要求但是如果你的属性名太特殊了，不能直接使用，需要使用[]来设置

**虽然如此，但是我们还是强烈建议属性名也按照标识符的规范命名**

也可以使用符号（symbol）作为属性名，来添加属性

**获取这种属性时，也必须使用symbol**

**使用symbol添加的属性，通常是那些不希望被外界访问的属性**

\- 使用[]去操作属性时，可以使用变量

*属性值*

​        \- 对象的属性值可以是任意的数据类型，也可以是一个对象

 **使用typeof检查一个对象时，会返回object**

对象字面量

可以直接使用{} 来创建对象
，可以直接向对象中添加属性

                - 语法：
    {
        属性名:属性值,

}

**枚举属性，指将对象中的所有的属性全部获取**

 for-in语句

 **\- 语法：**

​        for(let propName in 对象){

​          语句...

​        }

  \- for-in的循环体会执行多次，有几个属性就会执行几次， 每次执行时，都会将一个属性名赋值给我们所定义的变量

**注意：并不是所有的属性都可以枚举，比如 使用符号添加的属性**、

### 可变类型

\- 原始值都属于不可变类型，一旦创建就无法修改

\- 在内存中不会创建重复的原始值

- 对象属于可变类型
            - 对象创建完成后，可以任意的添加删除修改对象中的属性
                - 注意：
                - 当对两个对象进行相等或全等比较时，比较的是对象的内存地址
                - 如果有两个变量同时指向一个对象，
                    通过一个变量修改对象时，对另外一个变量也会产生影响

### 修改量和修改对象

修改对象

​          \- 修改对象时，如果有其他变量指向该对象

​            则所有指向该对象的变量都会受到影响

修改变量

​          \- 修改变量时，只会影响当前的变量

​            在使用变量存储对象时，很容易因为改变变量指向的对象，提高代码的复杂度

​          所以通常情况下，声明存储对象的变量时会使用const

 **注意**：

​          const只是禁止变量被重新赋值，对对象的修改没有任何影响

### 方法

\- 当一个对象的属性指向一个函数，

   那么我们就称这个函数是该对象的方法

  调用函数就称为调用对象的方法

## 函数

### 函数

函数（Function）
                - 函数也是一个对象
                                - 它具有其他对象所有的功能
                                - 函数中可以存储代码，且可以在需要时调用这些代码

​            语法：
​                function 函数名(){
​                    语句...
​                }

​            调用函数：
                - 调用函数就是执行函数中存储的代码
                                - 语法：
                    函数对象()

   使用typeof检查函数对象时会返回function

### 函数的创建方式

函数的定义方式：

1.**函数声明**

​          function 函数名(){

​            语句...

​          }

  2**.函数表达式**

​          const 变量 = function(){

​            语句...

​          }

 3.**箭头函数**

​          () => {

​            语句...

​          }

### 参数

形式参数
                - 在定义函数时，可以在函数中指定数量不等的形式参数（形参）
                                - 在函数中定义形参，就相当于在函数内部声明了对应的变量但是没有赋值

​            实际参数
                - 在调用函数时，可以在函数的()传递数量不等的实参
                                - 实参会赋值给其对应的形参
                                - 参数：
                                    1.如果实参和形参数量相同，则对应的实参赋值给对应的形参
                                    2.如果实参多余形参，则多余的实参不会使用
                                    3.如果形参多余实参，则多余的形参为undefined

                                                - 参数的类型
                    - JS中不会检查参数的类型，可以传递任何类型的值作为参数

​            1.函数声明
​                    function 函数名([参数]){
​                        语句...
​                    }

​            2.函数表达式
​                const 变量 = function([参数]){
​                    语句...
​                }

​            3.箭头函数
​                ([参数]) => {
​                    语句...
​                }

**定义参数时，可以为参数指定默认值，默认值会在没有对应实参时生效**

### 函数的返回值

在函数中，可以通过return关键字来指定函数的返回值

返回值就是函数的执行结果，函数调用完毕返回值便会作为结果返回

任何值都可以作为返回值使用（包括对象和函数之类）

 如果return后不跟任何值，则相当于返回undefined

 如果不写return，那么函数的返回值依然是undefined

 return一执行函数立即结束

### 箭头函数的默认值

箭头函数的返回值可以直接写在箭头后

如果直接在箭头后设置对象字面量为返回值时，对象字面量必须使用()括起来

### 作用域

作用域（scope）
                - 作用域指的是一个变量的可见区域
                                - 作用域有两种：
                    全局作用域
                        - 全局作用域在网页运行时创建，在网页关闭时消耗
                            - 所有直接编写到script标签中的代码都位于全局作用域中
                            - 全局作用域中的变量是全局变量，可以在任意位置访问

                    局部作用域
                        - 块作用域
                            - 块作用域是一种局部作用域
                            - 块作用域在代码块执行时创建，代码块执行完毕它就销毁
                            - 在块作用域中声明的变量是局部变量，只能在块内部访问，外部无法访问

### 函数作用域

函数作用域
                - 函数作用域也是一种局部作用域时产生，调用结束后销毁
                                - 函数作用域在函数调用   - 函数每次调用都会产生一个全新的函数作用域局部变量，只能在函数内部访问，外部无法访问

### 作用域链

作用域链

​        \- 当我们使用一个变量时，

​          JS解释器会优先在当前作用域中寻找变量，

​            如果找到了则直接使用

​            如果没找到，则去上一层作用域中寻找，找到了则使用

​            如果没找到，则继续去上一层寻找，以此类推

​            如果一直到全局作用域都没找到，则报错 xxx is not defined

### windows对象

Window对象

在浏览器中，浏览器为我们提供了一个window对象，可以直接访问的是浏览器窗口，通过该对象可以对浏览器窗口进行各种操作
除此之外window对象还负责存储JS中的内置对象和浏览器的宿主对象window对象的属性可以通过window对象访问，也可以直接访问
ndow对象的方法

### 提升

变量的提升

​          \- 使用var声明的变量，它会在所有代码执行前被声明

​            所以我们可以在变量声明前就访问变量

函数的提升

​          \- 使用函数声明创建的函数，会在其他代码执行前被创建

​            所以我们可以在函数声明前调用函数

 **let声明的变量实际也会提升，但是在赋值之前解释器禁止对该变量的访问**

### 立刻执行函数

在开发中应该尽量减少直接在全局作用域中编写代码！

所以我们的代码要尽量编写的局部作用域

如果使用let声明的变量，可以使用{}来创建块作用域

**立即执行函数（IIFE）**

​        \- 立即是一个匿名的函数，并它只会调用一次

​        \- 可以利用IIFE来创建一个一次性的函数作用域，避免变量冲突的问题

### this

函数在执行时，JS解析器每次都会传递进一个隐含的参数

这个参数就叫做 this
- this会指向一个对象

- this所指向的对象会根据函数调用方式的不同而不同
    1.以函数形式调用时，this指向的是window
    2.以方法的形式调用时，this指向的是调用方法的对象
    ...

    通过this可以在方法中引用调用方法的对象

**箭头函数没有自己的this，它的this有外层作用域决定，箭头函数的this和它的调用方式无关**

### 严格模式

JS运行代码的模式有两种：
                - 正常模式
                    - 默认情况下代码都运行在正常模式中，
                        在正常模式，语法检查并不严格
                        它的原则是：能不报错的地方尽量不报错
                    - 这种处理方式导致代码的运行性能较差

                                - 严格模式
                    - 在严格模式下，语法检查变得严格
                        1.禁止一些语法
                        2.更容易报错
                        3.提升了性能

                                - 在开发中，应该尽量使用严格模式，
                        这样可以将一些隐藏的问题消灭在萌芽阶段，
                        同时也能提升代码的运行性能

语法

"use strict"

## 面向对象

### 面向对象

面向对象编程（OOP）
                1. 程序是干嘛的？
                    - 程序就是对现实世界的抽象（照片就是对人的抽象）
                                2. 对象是干嘛的？
                    - 一个事物抽象到程序中后就变成了对象
                    - 在程序的世界中，一切皆对象
                                3. 面向对象的编程
                    - 面向对象的编程指，程序中的所有操作都是通过对象来完成
                    - 做任何事情之前都需要先找到它的对象，然后通过对象来完成各种操作

### **类**

使用Object创建对象的问题：
                    1. 无法区分出不同类型的对象
                                        2. 不方便批量创建对象

​                在JS中可以通过类（class）来解决这个问题：
                    1. 类是对象模板，可以将对象中的属性和方法直接定义在类中
                        定义后，就可以直接通过类来创建对象
                                        2. 通过同一个类创建的对象，我们称为同类对象
                        可以使用instanceof来检查一个对象是否是由某个类创建
                        如果某个对象是由某个类所创建，则我们称该对象是这个类的实例

​                语法：
​                    class 类名 {} // 类名要使用大驼峰命名
​                    const 类名 = class {}                      

​                通过类创建对象                    new 类()

### 属性

static test = "test静态属性" // 使用static声明的属性，是静态属性（类属性） Person.test

static hh = "静态属性"  // 静态属性只能通过类去访问 Person.hh

### 封装

面向对象的特点：
                封装、继承和多态

​            1.封装
                - 对象就是一个用来存储不同属性的容器
                                - 对象不仅存储属性，还要负责数据的安全
                                - 直接添加到对象中的属性，并不安全，因为它们可以被任意的修改
                                                - 如何确保数据的安全：
                        1.私有化数据
                            - 将需要保护的数据设置为私有，只能在类内部使用
                            2.提供setter和getter方法来开放对数据的操作
                                - 属性设置私有，通过getter setter方法操作属性带来的好处
                            1. 可以控制属性的读写权限
                                    2. 可以在方法中对属性的值进行验证

                                - 封装主要用来保证数据的安全
                                - 实现封装的方式：
                          1.属性私有化 加#
                          2.通过getter和setter方法来操作属性
                            get 属性名(){
                                    return this.#属性
                            }

                    ​    set 属性名(参数){
                    ​        this.#属性 = 参数
                    ​    }

### 多态

定义一个函数，这个函数将接收一个对象作为参数，他可以输出hello并打印对象的name属性

 多态

                - 在JS中不会检查参数的类型，所以这就意味着任何数据都可以作为参数传递
                                - 要调用某个函数，无需指定的类型，只要对象满足某些条件即可
                - 如果一个东西走路像鸭子，叫起来像鸭子，那么它就是鸭子
                                - 要调用某个函数，无需性

### 继承

\- 可以通过extends关键来完成继承

当一个类继承另一个类时，就相当于将另一个类中的代码复制到了当前类中（简单理解）

\- 继承发生时，被继承的类称为 父类（超类），继承的类称为 子类

\- 通过继承可以减少重复的代码，并且可以在不修改一个类的前提对其进行扩展

​        封装 —— 安全性

​        继承 —— 扩展性

​        多态 —— 灵活性

通过继承可以在不修改一个类的情况下对其进行扩展

​     \- OCP 开闭原则

​     \- 程序应该对修改关闭，对扩展开放      

### 对象的结构

对象中存储属性的区域实际有两个：
                    1. 对象自身
                        - 直接通过对象所添加的属性，位于对象自身中
                        - 在类中通过 x = y 的形式添加的属性，位于对象自身中

                                        2. 原型对象（prototype）
                        - 对象中还有一些内容，会存储到其他的对象里（原型对象）
                        - 在对象中会有一个属性用来存储原型对象，这个属性叫做__proto__
                        - 原型对象也负责为对象存储属性，
                            当我们访问对象中的属性时，会优先访问对象自身的属性，
                            对象自身不包含该属性时，才会去原型对象中寻找
                        - 会添加到原型对象中的情况：
                            1. 在类中通过xxx(){}方式添加的方法，位于原型中
                            2. 主动向原型中添加的属性或方法

### 原型对象

访问一个对象的原型对象
                    对象.__proto__
                    Object.getPrototypeOf(对象)

​                原型对象中的数据：
                    1. 对象中的数据（属性、方法等）
                                        2. constructor （对象的构造函数）

​                注意：
​                    **原型对象也有原型，这样就构成了一条原型链，根据对象的复杂程度不同，原型链的长度也不同**
​                        p对象的原型链：p对象 --> 原型 --> 原型 --> null
​                        obj对象的原型链：obj对象 --> 原型 --> null

​                    原型链：
                        - 读取对象属性时，会优先对象自身属性，
                            如果对象中有，则使用，没有则去对象的原型中寻找
                            如果原型中有，则使用，没有则去原型的原型中寻找
                            直到找到Object对象的原型（Object的原型没有原型（为null））
                                如果依然没有找到，则返回undefined

                                                - 作用域链，是找变量的链，找不到会报错
                                                                        - 原型链，是找属性的链，找不到会返回undefined

所有的同类型对象它们的原型对象都是同一个，

​          也就意味着，同类型对象的原型链是一样的

**原型的作用**：

​    原型就相当于是一个公共的区域，可以被所有该类实例访问，

​     可以将该类实例中，所有的公共属性（方法）统一存储到原型中

​      这样我们只需要创建一个属性，即可被所有实例访问

JS中继承就是通过原型来实现的,

当继承时，子类的原型就是一个父类的实例

​             在对象中有些值是对象独有的，像属性（name，age，gender）每个对象都应该有自己值，

​            但是有些值对于每个对象来说都是一样的，像各种方法，对于一样的值没必要重复的创建

### 修改原型

大部分情况下，我们是不需要修改原型对象
 注意：
     **千万不要通过类的实例去修改原型**

                               1. 通过一个对象影响所有同类对象，这么做不合适
                               2. 危险

​     处理通过__proto__能访问对象的原型外，
​     还可以通过类的prototype属性，来访问实例的原型
​     修改原型时，最好通过通过类去修改
​        好处：

                        1. 一修改就是修改所有实例的原型
                                                2. 无需创建实例即可完成对类的修改

​        原则：
                           1. 原型尽量不要手动改
                        1. 通过 类.prototype 属性去修改
                                                2. 要改也不要通过实例对象去改赋值

### instanceof 

用来检查一个对象是否是一个类的实例

 \- instanceof检查的是对象的原型链上是否有该类实例

只要原型链上有该类实例，就会返回true

​     dog -> Animal的实例 -> Object实例 -> Object原型

\- Object是所有对象的原型，所以任何和对象和Object进行instanceof运算都会返回true

### 旧类

早期JS中，直接通过函数来定义类

​     一个函数如果直接调用 xxx() 那么这个函数就是一个普通函数

​     一个函数如果通过new调用 new xxx() 那么这个函数就是一个够早函数

### new运算符

当使用new去调用一个函数时，这个函数将会作为构造函数调用，
    使用new调用函数时，将会发生这些事：

                       1. 创建一个普通的JS对象（Object对象 {}）, 为了方便，称其为新对象
                       2. 将构造函数的prototype属性设置为新对象的原型
                       3. 使用实参来执行构造函数，并且将新对象设置为函数中的this
                       4. 如果构造函数返回的是一个非原始值，则该值会作为new运算的返回值返回（千万不要这么做）
                       5. 如果构造函数的返回值是一个原始值或者没有指定返回值，则新的对象将会作为返回值返回
                             通常不会为构造函数指定返回值