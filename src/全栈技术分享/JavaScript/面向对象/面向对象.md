#面向对象（OOP）

**面向过程**（Procedure Oriented 简称PO ：如C语言）：

从名字可以看出它是注重过程的。当解决一个问题的时候，面向过程会把事情拆分成： 一个个函数和数据（用于方法的参数） 。然后按照一定的顺序，执行完这些方法（每个方法看作一个过程），等方法执行完了，事情就搞定了。

**面向对象**（Object Oriented简称OO ：如C++，JAVA等语言）：

看名字它是注重对象的。当解决一个问题的时候，面向对象会把事物抽象成对象的概念，就是说这个问题里面有哪些对象，然后给对象赋一些属性和方法，然后让每个对象去执行自己的方法，问题得到解决。

在我们开发时，很多时候我们要开发一些组件或第三方库，这时很多时候如果进行面向过程的编程，使用者就必须被动地调用我们的函数，多次传参，这是我们不希望看到的，因此，面向对象的方法逐渐成为了开发的主流

对于一个下围棋的程序：

面向过程：
	
建立一个二维数组作为棋盘

    `while(还没有人获胜){
		白棋走；
		黑棋走；
		判断胜负
	}`

面向对象：

建立一个围棋类 （类代表一类行为，可以复用）

    class Chess{
    为这个棋盘添加初始化棋盘的函数；
    添加主函数 start()（在主函数中调用走棋的函数和判断胜负的函数）
    添加走棋的函数
    isWin()	添加判断胜负的函数
    }

	将类实例化：let chess=new Chess
	调用主函数：chess.start();
	
相比于面向过程，面向对象将功能封装成方法调用，让用户无需关注函数的内部。同时具有了最好的复用性，比如我们要写一个五子棋，仅需要继承围棋类并重写部分方法：

	class five extend Chess{
		重写isWin方法即可
		isWin(){

	}
	}

类是一些行为的集合

new
## JavaScript中的面向对象编程（历史）

ES6

Object
构造函数

JavaScript虽然**万物皆对象**，但ES5中，JavaScript没有严格的面向对象编程的概念，一般我们通过操作prototype来给一个对象的方法

原型：可以理解为一个被创造的对象原来的形态，比如数组对象Array就是所有数组的原型；

prototype是一个对象的原型链，

__proto__ 连接了每一级的原型

当一个元素被调用一个方法，而其自身又没有这个方法，会**沿着原型链向上寻找，直到找到null**

因此：**原型链上包含了一个对象，包括其原型上的各种方法**

我们平时调用的各种方法也都是**原型上的方法**

String,Array等都是构造函数，也就是面向对象的写法

那么，在构造函数中，怎么能知道是谁（那个实例）在调用自己呢

this：面向对象语言中 this 表示当前对象的一个引用。

**在JS中，this指向当前作用域**，具体表现如下：
谁调用，this指向谁

* 默认情况下指向window
* 在被调用时指向调用他的对象（也可以说指向实例，这就是为什么构造函数上的方法可以用.调用的原因）
* 箭头函数指向上一级
* new时指向实例
* 隐式调用指向其调用者
* 
* 用call，apply，bind显式指定this的绑定者（调用者必须是函数）

**new 的本质：创造一个对象，将构造函数中的参数和方法传给它**

## ES6的面向对象
ES6在ES5的基础上，给我们增加了更语义化的面向对象写法，让我们更加简单地编写面向对象函数

