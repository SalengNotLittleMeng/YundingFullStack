# HTTP协议笔记

## 从输入url到页面展示的过程：
输入信息-发送请求-读取响应-渲染-页面呈现

以上是一个大致的解析流程，那么浏览器上面的url到我们看到网站的过程种究竟发生了什么事情呢？我们一点一点来看：

### url为什么要解析：

* 1.网络标准规定了URL只能由字母，数字和一些其它特殊符号组成

* 2.如果不转义会出现歧义，比如用？进行分隔时，我们不知道？究竟是分隔符还是接口名的一部分

**HTTP协议**的底层是TCP，HTTP（超文本传输）协议，是一种应用层协议应用层协议，能够处理请求和响应，它简单可扩展（可以自定义header），无状态，连接的双方彼此不知道之前的行为和状态，在需要传输信息时连接，传输信息后断开。

### DNS解析流程

* 当浏览器输入url后，操作系统首先会从hosts件(关联常用域名和ip地址的系统文件)里面寻找有没有这个记录，如果有就返回映射的ip地址
* 如果没有的话，在本地的DNS解析器中查找是否有缓存
* 如果没有的话，在计算机上配置的DNS服务器上找是否有缓存
* 如果还没有，去全球DNS上查找。首先查找最后一个点后面的部分，查找不到的话找前一个点的后面，知道检索完整个域名

注意：我们可以在html页面头部写入dns缓存地址：

    `<meta http-equiv="x-dns-prefetch-control" content="on" />
	<link rel="dns-prefetch" href="http://bdimg.share.baidu.com" />`

### 三次握手
三次握手：

第一次握手：主机A发送位码为SYN＝1的TCP包给服务器，并且随机产生一个作为确认号（这是tcp包的一部分），主机B收到SYN码后直到A要求建立连接;


第二次握手：主机B收到请求后，向A发送确认号（主机A的seq+1），syn=1，seq = 随机数 的TCP包；


主机A收到后检查确认号是否正确，即第一次A发送的确认号是否+1了，以及位码ack是否为1，若正确，主机A会再发送确认号(主机B的seq+1)，ack=1，主机B收到后确认seq值与ack=1则连接建立成功

### 请求文件
当三次握手后，主机和服务器已经建立了连接，这时候就可以请求资源了，如果文件本身就有缓存，直接从浏览器中取出，没有的话则需要去后台去拿。

注意，第一次请求资源时会拿到一个date，这个数据会用于之后的对比。设置了max-age,当启用缓存时会用当前事件跟这个date对比，看是否过期。如果过期会强制更新缓存。如果是协商缓存，则会比较Etag并根据比对成功与否返回200或304

## 笔记部分

### HTTP协议的版本

* HTTP协议0.9版本（单行协议）：get-目标地址，响应只有HTML文档
* HTTP协议1.0版本：-初步构建了可扩展性，增加了header和状态码，支持多种文档类型
* HTTP协议1.1版本：链接复用，缓存，内容协商
* HTTP协议2.0版本：让传输更加稳定，压缩header，服务器推送，二进制协商


安全性：不会修改服务器数据

幂等：执行一次与多次效果一一致

restfu; API:url代表一种资源

### 缓存
强缓存：expires，时间戳，max-age：单位是秒，最大缓存时间，强缓存不知道服务端的资源是否改变，一旦资源过期，在重新向服务器请求资源前，缓存不能被使用

协商缓存：资源的特定版本的特定修饰符，保留最后修改，会检查是否更新

缓存：浏览器发起请求时会检验是否有缓存，强缓存存在的话，直接返回上一次的资源，没有的话，上一次响应头中是否有tag，没有的话发起下一次请求，否则检验协议缓存

### 通信相关的概念：

* 帧：通信的最小单位，每个帧都包含一个帧头
* 消息：与逻辑请求或响应消息对应的完整的一系列帧
* 数据流：已建立的连接内的双向字节流，可以承载一条或多条消息

建立的链接可以复用

CDN：资源分发的网络，根据用户的位置就近分发

可以通过每次更改文件名，让资源轻质更新

### ip地址

域名，主机名 端口号 https：默认443，http:默认80端口

这里补充一下ip地址的内容，入营考试的时候就在这道题上吃了亏，ip地址一共有五类：

* A类：1.0.0.0~126.255.255.255
* B类：128.0.0.0~191.255.255.255
* C类：192.0.0.0~223.255.255.255
* D类：224.0.0.0~239.255.255.255
* E类：240.0.0.0~254.255.255.255
* 其中127.0.0.0~127.255.255.255用于环回测试，D类地址用于组播，E类地址用于科研

**端口号**可以用来标识同一个主机上通信的不同应用程序（就是哪个应用程序在使用这个端口）

### 跨域问题解决：
1.CORS（Cross-Origin Resource Sharing，跨域资源共享）：复杂请求会先发出预请求，以获知服务端是否允许该跨域请求

2.代理服务器（与浏览器同域）：同源策略是浏览器的安全策略，不是HTTP的

### QUIC：o-rtt建联

类似TCP传输可靠，类似TCS加密，用户空间的阻塞控制，向前纠错

考虑API的分发和合并